; The rst vectors are unused.
SECTION "rst 00", ROM0
	rst $38
SECTION "rst 08", ROM0
	rst $38
SECTION "rst 10", ROM0
	rst $38
SECTION "rst 18", ROM0
	rst $38
SECTION "rst 20", ROM0
	rst $38
SECTION "rst 28", ROM0
	rst $38
SECTION "rst 30", ROM0
	rst $38
SECTION "rst 38", ROM0
	rst $38

; Hardware interrupts
SECTION "vblank", ROM0
	jp VBlank
SECTION "hblank", ROM0
	rst $38
SECTION "timer",  ROM0
	jp Timer
SECTION "serial", ROM0
	jp Serial
SECTION "joypad", ROM0
	reti


SECTION "Home", ROM0

; **DisableLCD**  
; LCDを無効化する  
; - - -  
; VBlank期間までまってからLCDCフラグを変更してLCDを無効化する
DisableLCD::
	; 割り込みフラグが立っているときはクリア
	xor a
	ld [rIF], a
	; IEのVBlankフラグをクリアする (VBlankを無効化)
	ld a, [rIE]
	ld b, a ; bにクリア前のIEを退避
	res 0, a
	ld [rIE], a

	; VBlankが始まるタイミングまで待機(VBlankは起きない)
.wait
	ld a, [rLY]
	cp LY_VBLANK
	jr nz, .wait

	; VBlankのタイミング開始
	; LCDCはVBlank期間内に変更しないといけない

	; a &= %1111_0001 つまり スプライトの無効化?
	ld a, [rLCDC]
	and $ff ^ rLCDC_ENABLE_MASK ; a &= %1111_0001
	ld [rLCDC], a

	; bに退避した元のIEを復帰して終了
	ld a, b
	ld [rIE], a
	ret

; **EnableLCD**  
; LCD を有効にする  
; - - -  
; LCDC の bit7 をセットすることで有効にする  
EnableLCD::
	ld a, [rLCDC]
	set rLCDC_ENABLE, a
	ld [rLCDC], a
	ret

; **ClearSprites**  
; wOAMBufferを 全部0 でクリアする
ClearSprites::
	xor a
	ld hl, wOAMBuffer
	ld b, 40 * 4
.loop
	ld [hli], a
	dec b
	jr nz, .loop
	ret

; **HideSprites**  
; wOAMBuffer に格納された OAM を全て非表示にする  
; - - -  
; 具体的には OAM の Y座標 を 160にすることで非表示にする
HideSprites::
	ld a, 160
	ld hl, wOAMBuffer
	ld de, 4
	ld b, 40
.loop
; {
	ld [hl], a	; Y = 160 -> 非表示
	add hl, de 	; +4 次の OAMへ
	dec b
	jr nz, .loop
; }
	ret

INCLUDE "home/copy.asm"


SECTION "Entry", ROM0

	nop
	jp Start


SECTION "Header", ROM0

	; The header is generated by rgbfix.
	; The space here is allocated to prevent code from being overwritten.

	ds $150 - $104


SECTION "Main", ROM0

Start::
	cp GBC
	jr z, .gbc
	xor a
	jr .ok
.gbc
	ld a, 0
.ok
	ld [wGBC], a
	jp Init


INCLUDE "home/joypad.asm"
INCLUDE "data/map_header_pointers.asm"
INCLUDE "home/overworld.asm"

; **CheckForUserInterruption**  
; cフレームの間 に `↑+Select+B` or `Start` or `A` が 押されたかを確認  
; - - -  
; イントロとタイトル画面でのみ利用される関数  
; 
; OUTPUT: carry = 1(押された) or 0(押されなかった)
CheckForUserInterruption::
	call DelayFrame

	push bc
	call JoypadLowSensitivity
	pop bc

	ld a, [hJoyHeld]
	cp D_UP + SELECT + B_BUTTON
	jr z, .input

	ld a, [hJoy5]
	and START | A_BUTTON
	jr nz, .input

	dec c
	jr nz, CheckForUserInterruption

	and a
	ret

.input
	scf
	ret

; **LoadDestinationWarpPosition**  
; マップを切り替えたときに出現先の位置データを取得する関数  
; - - -  
; INPUT:  
; a = ワープ先の出現地点のwarp-to ID  
; hl = ???  
LoadDestinationWarpPosition::
	ld b, a ; b = a
	
	; バンクを [wPredefParentBank] に切り替え
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, [wPredefParentBank]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	; bc = (warp-to ID) * 3   warp-toエントリは3バイトなので
	ld a, b
	add a
	add a
	ld c, a
	ld b, 0

	; wCurrentTileBlockMapViewPointer, wYCoord, wXCoordを更新
	add hl, bc
	ld bc, 4
	ld de, wCurrentTileBlockMapViewPointer
	call CopyData

	; バンクを元に戻して終了
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **DrawHPBar**  
; HPバーを描画する  
; - - -  
; dタイルの長さのHPバーを描画し、eピクセルだけHPを満たす  
; HPバーの右端は [wHPBarType] によって形状が変わる  
; 
; INPUT:  
; c = If c is nonzero, show at least a sliver regardless.  
; d = HPバーのタイル長  
; e = HPバーに満たすHPのピクセル  
; hl = HPバーを描画する場所  
DrawHPBar::
	push hl
	push de
	push bc

	; HPバーの左に "HP:" を描画
	ld a, $71
	ld [hli], a
	ld a, $62
	ld [hli], a

	push hl

; 空のHPバー を描画
	ld a, $63
.draw
; {
	ld [hli], a
	dec d
	jr nz, .draw
; }

; HPバーの右端(タイル番号 0x6d or 0x6c) を描画
	ld a, [wHPBarType]
	dec a
	ld a, $6d 	; 0x6d: status screen and battle
	jr z, .ok
	dec a 		; 0x6c: pokemon menu
.ok
	ld [hl], a

	pop hl

	ld a, e
	and a
	jr nz, .fill

	; If c is nonzero, draw a pixel anyway.
	ld a, c
	and a
	jr z, .done
	ld e, 1

.fill
	ld a, e
	sub 8
	jr c, .partial
	ld e, a
	ld a, $6b ; full
	ld [hli], a
	ld a, e
	and a
	jr z, .done
	jr .fill

.partial
	; Fill remaining pixels at the end if necessary.
	ld a, $63 ; empty
	add e
	ld [hl], a
.done
	pop bc
	pop de
	pop hl
	ret


; **LoadMonData**  
; ポケモンのデータを複数のsourceの1つから wLoadedMon にロードし、ポケモンのbase statsを wMonHeader にロードする
; - - -  
; 
; INPUT:  
; [wWhichPokemon] = パーティやボックスのポケモンのインデックス  
; [wMonDataLocation] = source (00: プレイヤーのパーティ/01: エネミーのパーティ/02: 現在のbox/03: 育て屋)  
; 
; OUTPUT:  
; [wcf91] = ポケモンのID  
; [wLoadedMon] = Pokemon Data  
; [wMonHeader] = Pokemon Header  
LoadMonData::
	jpab LoadMonData_

OverwritewMoves::
; Write c to [wMoves + b]. Unused.
	ld hl, wMoves
	ld e, b
	ld d, 0
	add hl, de
	ld a, c
	ld [hl], a
	ret

; **LoadFlippedFrontSpriteByMonIndex**  
; ポケモンの左右反転した正面グラフィックデータを取得する  
; - - -  
; INPUT:  
; - hl = グラフィックデータをロードする先(BGMapアドレスなど)  
; - [wcf91] = ポケモンID
LoadFlippedFrontSpriteByMonIndex::
	ld a, 1
	ld [wSpriteFlipped], a

; **LoadFrontSpriteByMonIndex**  
; ポケモンの正面グラフィックデータを取得する  
; - - -  
; INPUT:  
; - hl = グラフィックデータをロードする先(BGMapアドレスなど)  
; - [wcf91] = ポケモンID
LoadFrontSpriteByMonIndex::
	push hl ; stack_depth = 0
	
	; a = [wd11e] = ポケモンID
	ld a, [wd11e]
	push af ; stack_depth = 1
	ld a, [wcf91]
	ld [wd11e], a
	
	; a = 図鑑番号
	predef IndexToPokedex
	ld hl, wd11e
	ld a, [hl]

	; [wd11e] = ポケモンID
	pop bc ; stack_depth = 1
	ld [hl], b

	; 151 >= 図鑑番号 >= 0 -> .validDexNumber
	; 図鑑番号 == 0 or 図鑑番号 > 151 -> .invalidDexNumber
	and a
	pop hl
	jr z, .invalidDexNumber
	cp NUM_POKEMON + 1
	jr c, .validDexNumber

.invalidDexNumber
	; 図鑑番号が不正のときはサイドンのIDを入れて終了
	ld a, RHYDON ; $1
	ld [wcf91], a
	ret

.validDexNumber
	; ポケモンのグラフィックデータをVRAMに配置
	push hl
	ld de, vFrontPic
	call LoadMonFrontSprite
	pop hl

	; CopyUncompressedPicToHL のあるバンクに切り替え
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, Bank(CopyUncompressedPicToHL)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	; a = [hStartTileID] = 0
	xor a
	ld [hStartTileID], a
	call CopyUncompressedPicToHL ; hl = 関数呼び出し時の hl

	xor a
	ld [wSpriteFlipped], a ; [wSpriteFlipped] = 0
	; タイルを復帰
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret


; **PlayCry**  
; ポケモンの鳴き声を流す  
; - - -  
; INPUT: a = ポケモンID  
PlayCry::
	call GetCryData
	call PlaySound
	jp WaitForSoundToFinish

; **GetCryData**  
; 鳴き声のデータをロードする  
; - - -  
; INPUT: a = ポケモンID  
GetCryData::
	dec a
	ld c, a
	ld b, 0
	ld hl, CryData
	add hl, bc
	add hl, bc
	add hl, bc

	ld a, BANK(CryData)
	call BankswitchHome
	ld a, [hli]
	ld b, a ; cry id
	ld a, [hli]
	ld [wFrequencyModifier], a
	ld a, [hl]
	ld [wTempoModifier], a
	call BankswitchBack

	; Cry headers have 3 channels,
	; and start from index $14,
	; so add 3 times the cry id.
	ld a, b
	ld c, $14
	rlca ; * 2
	add b
	add c
	ret

; **DisplayPartyMenu**  
; 手持ち画面を描画しプレイヤーのアクションを待つ  
; - - -  
; プレイヤーが手持ちでA/Bボタンを押すまで続く  
; 
; OUTPUT:  
; carry = 1(ポケモンを選択した) or 0(手持ち画面からBボタンでExit)  
; [wcf91] = [wBattleMonSpecies2] = 選択したポケモンID  
DisplayPartyMenu::
	; [hTilesetType] = 0
	ld a, [hTilesetType]
	push af
	xor a
	ld [hTilesetType], a

	; 手持ち画面を描画
	call GBPalWhiteOutWithDelay3
	call ClearSprites
	call PartyMenuInit
	call DrawPartyMenu

	jp HandlePartyMenuInput 	; ret

GoBackToPartyMenu::
	ld a, [hTilesetType]
	push af
	xor a
	ld [hTilesetType], a
	call PartyMenuInit
	call RedrawPartyMenu
	jp HandlePartyMenuInput

; **PartyMenuInit**  
; 手持ち画面を開く時のInit処理  
; - - -  
; 2bppデータのロード、menuに関する変数の初期化を行う  
; 手持ち画面の描画はしない  
PartyMenuInit::
	; バンク1にスイッチ
	ld a, 1 ; hardcoded bank
	call BankswitchHome

	call LoadHpBarAndStatusTilePatterns

	; 手持ち画面ではテキストを一気に表示するので
	ld hl, wd730
	set 6, [hl]

	; 変数を初期化
	xor a 
	ld [wMonDataLocation], a	; PLAYER_PARTY_DATA
	ld [wMenuWatchMovingOutOfBounds], a	; menu wrap を有効に 

	; menuの一番上の項目でのカーソル位置を (0, 1) に設定
	ld hl, wTopMenuItemY
	inc a
	ld [hli], a ; wTopMenuItemY
	xor a
	ld [hli], a ; wTopMenuItemX

	; 記憶していたカーソル位置を復元
	ld a, [wPartyAndBillsPCSavedMenuItem]
	push af
	ld [hli], a ; wCurrentMenuItem
	inc hl

; [wMaxMenuItem] = 手持ち数-1 or 0(最初のポケモンをもらう前)
	ld a, [wPartyCount]	; a = 手持ちのポケモン数
	and a
	jr z, .storeMaxMenuItemID
	dec a
.storeMaxMenuItemID
	ld [hli], a ; wMaxMenuItem

; [wMenuWatchedKeys] = A_BUTTON(手持ち画面から抜けれない) or A_BUTTON | B_BUTTON(抜けれる)
	ld a, [wForcePlayerToChooseMon]
	and a
	ld a, A_BUTTON | B_BUTTON
	jr z, .next
	xor a
	ld [wForcePlayerToChooseMon], a
	inc a ; a = A_BUTTON
.next
	ld [hli], a ; menu watched keys

	; [wLastMenuItem] = [wPartyAndBillsPCSavedMenuItem]
	pop af		; a = [wPartyAndBillsPCSavedMenuItem]
	ld [hl], a 	; old menu item ID
	ret

; **HandlePartyMenuInput**  
; 手持ち画面でのキー入力に対処する  
; - - -  
; プレイヤーが手持ちでA/Bボタンを押すまで続く  
; 
; OUTPUT:  
; carry = 1(ポケモンを選択した) or 0(手持ち画面からBボタンでExit)  
; [wcf91] = [wBattleMonSpecies2] = 選択したポケモンID  
HandlePartyMenuInput::
	; menu wrap を有効化
	ld a, 1
	ld [wMenuWrappingEnabled], a

	; プレイヤーのA/Bボタンを待つ(PartyMenuInitでA/Bボタンのみハンドルする様にしている)
	ld a, $40
	ld [wPartyMenuAnimMonEnabled], a
	call HandleMenuInput_

	; ポケモンが選択された状態にする  
	call PlaceUnfilledArrowMenuCursor
	ld b, a	; b = プレイヤーのキー入力
	xor a
	ld [wPartyMenuAnimMonEnabled], a
	ld a, [wCurrentMenuItem]
	ld [wPartyAndBillsPCSavedMenuItem], a

	; ???
	ld hl, wd730
	res 6, [hl] ; turn on letter printing delay

	; セレクトを押されている状態でA/Bボタンが押された時 -> .swappingPokemon
	ld a, [wMenuItemToSwap]
	and a
	jp nz, .swappingPokemon

	; タイルセットを戻す
	pop af
	ld [hTilesetType], a

	; Bボタンが押された時 -> .noPokemonChosen
	bit 1, b
	jr nz, .noPokemonChosen

	; そもそも手持ちのポケモンが0匹(ありえないが) -> .noPokemonChosen
	ld a, [wPartyCount]
	and a
	jr z, .noPokemonChosen

	; a = ポケモンID
	ld a, [wCurrentMenuItem]
	ld [wWhichPokemon], a
	ld hl, wPartySpecies
	ld b, 0
	ld c, a
	add hl, bc
	ld a, [hl]

	ld [wcf91], a
	ld [wBattleMonSpecies2], a
	call BankswitchBack
	and a
	ret

.noPokemonChosen
	call BankswitchBack
	scf
	ret

.swappingPokemon
	; Aボタンが押された
	bit 1, b
	jr z, .handleSwap

	; Bボタンが押された
.cancelSwap
	; 通常の手持ち画面に戻す
	callba ErasePartyMenuCursors
	xor a
	ld [wMenuItemToSwap], a
	ld [wPartyMenuTypeOrMessageID], a
	call RedrawPartyMenu
	jr HandlePartyMenuInput

.handleSwap
	; ポケモンを入れ替える  
	ld a, [wCurrentMenuItem]
	ld [wWhichPokemon], a
	callba SwitchPartyMon
	jr HandlePartyMenuInput

; **DrawPartyMenu**  
; 手持ち画面を描画する  
; - - -  
; 手持ちmenuや回復アイテム・技マシンの対象選択など全ての手持ち画面を担当する  
; INPUT: [wPartyMenuTypeOrMessageID] = menuType(x < $F0のとき) or messageID(x >= $F0のとき)  
DrawPartyMenu::
	ld hl, DrawPartyMenu_
	jr DrawPartyMenuCommon

; **RedrawPartyMenu**  
; 手持ち画面を描画する  
; - - -  
; 手持ちmenuや回復アイテム・技マシンの対象選択など全ての手持ち画面を担当する  
; INPUT: [wPartyMenuTypeOrMessageID] = menuType(x < $F0のとき) or messageID(x >= $F0のとき)  
RedrawPartyMenu::
	ld hl, RedrawPartyMenu_
	; fallthrough

; **DrawPartyMenuCommon**  
; hl で指定したアドレスにジャンプする  
; - - -  
; INPUT: hl = DrawPartyMenu_ or RedrawPartyMenu_
DrawPartyMenuCommon::
	ld b, BANK(RedrawPartyMenu_)
	jp Bankswitch

; **PrintStatusCondition**  
; ポケモンの状態異常を描画する(正常な時も含めて)  
; - - -  
; INPUT:  
; de = status condition(`box_struct` の XXXStatus e.g. wLoadedMonStatus)  
; hl = 描画先  
; 
; OUTPUT:  
; a = 0(ポケモンが何の状態異常もない) or 1(なんらかの状態異常だった)  
PrintStatusCondition::
	; 対象の HP が 0でないときは、処理を PrintStatusConditionNotFainted に任せる
	push de
	dec de
	dec de ; de = address of current HP
	ld a, [de]
	ld b, a
	dec de
	ld a, [de]
	or b
	pop de
	jr nz, PrintStatusConditionNotFainted
	
	; 対象のHPが 0 のときは状態異常を無視して FNT(ひんし)を出す
	ld a, "F"
	ld [hli], a
	ld a, "N"
	ld [hli], a
	ld [hl], "T"
	and a
	ret

; **PrintStatusConditionNotFainted**  
; 瀕死じゃないポケモンの状態異常を描画する  
; - - -  
; INPUT:  
; de = status condition(`box_struct` の XXXStatus e.g. wLoadedMonStatus)  
; hl = 描画先  
PrintStatusConditionNotFainted:
	; PrintStatusAilmentのあるバンクにスイッチ
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(PrintStatusAilment)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call PrintStatusAilment
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **PrintLevel**  
; ポケモンのレベルを描画する  
; - - -  
; レベルが100以上のときは ":L" は描画しない  
; 
; INPUT:  
; hl = 描画先  
; [wLoadedMonLevel] = level  
PrintLevel::
	ld a, $6e ; ":L" tile ID
	ld [hli], a
	ld c, 2 ; number of digits
	ld a, [wLoadedMonLevel] ; level
	cp 100
	jr c, PrintLevelCommon
; if level at least 100, write over the ":L" tile
	dec hl
	inc c ; increment number of digits to 3
	jr PrintLevelCommon

; prints the level without leaving off ":L" regardless of level
; INPUT:
; hl = destination address
; [wLoadedMonLevel] = level
PrintLevelFull::
	ld a, $6e ; ":L" tile ID
	ld [hli], a
	ld c, 3 ; number of digits
	ld a, [wLoadedMonLevel] ; level

PrintLevelCommon::
	ld [wd11e], a
	ld de, wd11e
	ld b, LEFT_ALIGN | 1 ; 1 byte
	jp PrintNumber

GetwMoves::
; Unused. Returns the move at index a from wMoves in a
	ld hl, wMoves
	ld c, a
	ld b, 0
	add hl, bc
	ld a, [hl]
	ret

; **GetMonHeader**  
; ポケモンの Pokemon Header を wMonHeader に格納する  
; - - -  
; Pokemon Headerについてはドキュメント参照  
; INPUT: [wd0b5] = ポケモンID  
GetMonHeader::
	; バンクスイッチ
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(BaseStats)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	push bc
	push de
	push hl

	; wd11eを使うので元の値を退避
	ld a, [wd11e]
	push af

	; [wd11e] = ポケモンのID
	ld a, [wd0b5]
	ld [wd11e], a

	; ゆうれいやカブトプス、プテラの化石、ミュウは特別な処理
	ld de, FossilKabutopsPic
	ld b, $66 ; size of Kabutops fossil and Ghost sprites
	cp FOSSIL_KABUTOPS ; Kabutops fossil
	jr z, .specialID
	ld de, GhostPic
	cp MON_GHOST ; Ghost
	jr z, .specialID
	ld de, FossilAerodactylPic
	ld b, $77 ; size of Aerodactyl fossil sprite
	cp FOSSIL_AERODACTYL ; Aerodactyl fossil
	jr z, .specialID
	cp MEW
	jr z, .mew

	; a = ポケモンの図鑑番号 - 1
	predef IndexToPokedex
	ld a, [wd11e]
	dec a

	; hl = ポケモンのbase stat
	ld bc, MonBaseStatsEnd - MonBaseStats
	ld hl, BaseStats
	call AddNTimes

	; wMonHeaderにbase statをコピー
	ld de, wMonHeader
	ld bc, MonBaseStatsEnd - MonBaseStats
	call CopyData
	jr .done
.specialID
	ld hl, wMonHSpriteDim
	ld [hl], b ; write sprite dimensions
	inc hl
	ld [hl], e ; write front sprite pointer
	inc hl
	ld [hl], d
	jr .done
.mew
	ld hl, MewBaseStats
	ld de, wMonHeader
	ld bc, MonBaseStatsEnd - MonBaseStats
	ld a, BANK(MewBaseStats)
	call FarCopyData
.done
	; [wMonHIndex] = ポケモンID
	ld a, [wd0b5]
	ld [wMonHIndex], a

	; 退避しておいた値を復帰
	pop af
	ld [wd11e], a
	pop hl
	pop de
	pop bc
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; copy party pokemon's name to wcd6d
GetPartyMonName2::
	ld a, [wWhichPokemon] ; index within party
	ld hl, wPartyMonNicks

; **GetPartyMonName**  
; ポケモンの名前を取得する  
; - - -  
; INPUT:  
; a = 対象のポケモンのインデックス  
; hl = ポケモンの名前リスト(wBoxMonNicks or wPartyMonNicks or wDayCareMonName)  
; 
; OUTPUT:  
; de = ポケモンの名前のポインタ  
; [wcd6d] = ポケモンの名前の文字列データ  
GetPartyMonName::
	push hl
	push bc
	call SkipFixedLengthTextEntries ; add NAME_LENGTH to hl, a times
	ld de, wcd6d
	push de
	ld bc, NAME_LENGTH
	call CopyData
	pop de
	pop bc
	pop hl
	ret

; **PrintBCDNumber**  
; BCD数値を表示するための関数
; - - -
; 
; INPUT:  
; - de = BCD数値のアドレス  
; - hl = 表示先のアドレス  
; - c[7] = 1: print leading zeroes 0: print leading zeroes
; - c[6] = 1: left-align the string (do not pad empty digits with spaces) 0: right-align the string 
; - c[5] = 1: print currency symbol at the beginning of the string 0: do not print the currency symbol
; - c[0:4] = length of BCD number in bytes
; 
; Note that bits 5 and 7 are modified during execution. The above reflects
; their meaning at the beginning of the functions's execution.  
PrintBCDNumber::
	ld b, c ; save flags in b
	res 7, c
	res 6, c
	res 5, c ; c now holds the length
	bit 5, b
	jr z, .loop
	bit 7, b
	jr nz, .loop
	ld [hl], "¥"
	inc hl
.loop
	ld a, [de]
	swap a
	call PrintBCDDigit ; print upper digit
	ld a, [de]
	call PrintBCDDigit ; print lower digit
	inc de
	dec c
	jr nz, .loop
	bit 7, b ; were any non-zero digits printed?
	jr z, .done ; if so, we are done
.numberEqualsZero ; if every digit of the BCD number is zero
	bit 6, b ; left or right alignment?
	jr nz, .skipRightAlignmentAdjustment
	dec hl ; if the string is right-aligned, it needs to be moved back one space
.skipRightAlignmentAdjustment
	bit 5, b
	jr z, .skipCurrencySymbol
	ld [hl], "¥"
	inc hl
.skipCurrencySymbol
	ld [hl], "0"
	call PrintLetterDelay
	inc hl
.done
	ret

PrintBCDDigit::
	and $f
	and a
	jr z, .zeroDigit
.nonzeroDigit
	bit 7, b ; have any non-space characters been printed?
	jr z, .outputDigit
; if bit 7 is set, then no numbers have been printed yet
	bit 5, b ; print the currency symbol?
	jr z, .skipCurrencySymbol
	ld [hl], "¥"
	inc hl
	res 5, b
.skipCurrencySymbol
	res 7, b ; unset 7 to indicate that a nonzero digit has been reached
.outputDigit
	add "0"
	ld [hli], a
	jp PrintLetterDelay
.zeroDigit
	bit 7, b ; either printing leading zeroes or already reached a nonzero digit?
	jr z, .outputDigit ; if so, print a zero digit
	bit 6, b ; left or right alignment?
	ret nz
	inc hl ; if right-aligned, "print" a space by advancing the pointer
	ret

; **UncompressMonSprite**  
; 圧縮されたポケモンのグラフィックデータを解凍する  
; - - -  
; 対象は正面グラでも背面グラでも可  
; 前提として対象のPokemon Headerがロード済みである必要がある  
; 
; INPUT:  
; [wMonHeader] = 対象のポケモンのPokemon Header  
; hl = $b(正面グラ) or $d(背面グラ)  
; [wcf91] = ポケモンID  
UncompressMonSprite::
	; hl = wMonHFrontSprite or wMonHBackSprite
	ld bc, wMonHeader
	add hl, bc
	; a = スプライトのグラのアドレス
	ld a, [hli]
	ld [wSpriteInputPtr], a    ; fetch sprite input pointer
	ld a, [hl]
	ld [wSpriteInputPtr+1], a

; [wcf91]に格納されているポケモンIDを使ってポケモンのグラがあるバンクを決定する  
; Mew -> bank 1
; Kabutops fossil -> bank $B
; PokemonID < $1F -> bank 9
; $1F ≤ PokemonID < $4A -> bank $A
; $4A ≤ PokemonID < $74 -> bank $B
; $74 ≤ PokemonID < $99 -> bank $C
; $99 ≤ PokemonID ->       bank $D
	ld a, [wcf91] ; XXX name for this ram location
	ld b, a
	cp MEW
	ld a, BANK(MewPicFront)
	jr z, .GotBank
	ld a, b
	cp FOSSIL_KABUTOPS
	ld a, BANK(FossilKabutopsPic)
	jr z, .GotBank
	ld a, b
	cp TANGELA + 1
	ld a, BANK(TangelaPicFront)
	jr c, .GotBank
	ld a, b
	cp MOLTRES + 1
	ld a, BANK(MoltresPicFront)
	jr c, .GotBank
	ld a, b
	cp BEEDRILL + 2
	ld a, BANK(BeedrillPicFront)
	jr c, .GotBank
	ld a, b
	cp STARMIE + 1
	ld a, BANK(StarmiePicFront)
	jr c, .GotBank
	ld a, BANK(VictreebelPicFront)
.GotBank
	; このとき a: ポケモンのグラがあるバンク番号
	jp UncompressSpriteData 

; **LoadMonFrontSprite**
; ポケモンの正面のグラフィックデータをdeにロードする
; - - -  
; INPUT: [wcf91] = ポケモンID
LoadMonFrontSprite::
	push de
	ld hl, wMonHFrontSprite - wMonHeader ; hl = b => 正面グラ
	call UncompressMonSprite
	ld hl, wMonHSpriteDim
	ld a, [hli]
	ld c, a
	pop de
	; fall through

; postprocesses uncompressed sprite chunks to a 2bpp sprite and loads it into video ram
; calculates alignment parameters to place both sprite chunks in the center of the 7*7 tile sprite buffers
; de: destination location
; a,c:  sprite dimensions (in tiles of 8x8 each)
LoadUncompressedSpriteData::
	push de
	and $f
	ld [H_SPRITEWIDTH], a ; each byte contains 8 pixels (in 1bpp), so tiles=bytes for width
	ld b, a
	ld a, $7
	sub b      ; 7-w
	inc a      ; 8-w
	srl a      ; (8-w)/2     ; horizontal center (in tiles, rounded up)
	ld b, a
	add a
	add a
	add a
	sub b      ; 7*((8-w)/2) ; skip for horizontal center (in tiles)
	ld [H_SPRITEOFFSET], a
	ld a, c
	swap a
	and $f
	ld b, a
	add a
	add a
	add a     ; 8*tiles is height in bytes
	ld [H_SPRITEHEIGHT], a
	ld a, $7
	sub b      ; 7-h         ; skip for vertical center (in tiles, relative to current column)
	ld b, a
	ld a, [H_SPRITEOFFSET]
	add b     ; 7*((8-w)/2) + 7-h ; combined overall offset (in tiles)
	add a
	add a
	add a     ; 8*(7*((8-w)/2) + 7-h) ; combined overall offset (in bytes)
	ld [H_SPRITEOFFSET], a
	xor a
	ld [$4000], a
	ld hl, sSpriteBuffer0
	call ZeroSpriteBuffer   ; zero buffer 0
	ld de, sSpriteBuffer1
	ld hl, sSpriteBuffer0
	call AlignSpriteDataCentered    ; copy and align buffer 1 to 0 (containing the MSB of the 2bpp sprite)
	ld hl, sSpriteBuffer1
	call ZeroSpriteBuffer   ; zero buffer 1
	ld de, sSpriteBuffer2
	ld hl, sSpriteBuffer1
	call AlignSpriteDataCentered    ; copy and align buffer 2 to 1 (containing the LSB of the 2bpp sprite)
	pop de
	jp InterlaceMergeSpriteBuffers

; copies and aligns the sprite data properly inside the sprite buffer
; sprite buffers are 7*7 tiles in size, the loaded sprite is centered within this area
AlignSpriteDataCentered::
	ld a, [H_SPRITEOFFSET]
	ld b, $0
	ld c, a
	add hl, bc
	ld a, [H_SPRITEWIDTH]
.columnLoop
	push af
	push hl
	ld a, [H_SPRITEHEIGHT]
	ld c, a
.columnInnerLoop
	ld a, [de]
	inc de
	ld [hli], a
	dec c
	jr nz, .columnInnerLoop
	pop hl
	ld bc, 7*8    ; 7 tiles
	add hl, bc    ; advance one full column
	pop af
	dec a
	jr nz, .columnLoop
	ret

; fills the sprite buffer (pointed to in hl) with zeros
ZeroSpriteBuffer::
	ld bc, SPRITEBUFFERSIZE
.nextByteLoop
	xor a
	ld [hli], a
	dec bc
	ld a, b
	or c
	jr nz, .nextByteLoop
	ret

; **InterlaceMergeSpriteBuffers**  
; buffer0 と buffer1 の49タイル分の 1bppフォーマット のスプライトのデータを 2bppデータにして de が示すアドレスに 配置する  
; - - -  
; buffer0 と buffer1 の7*7サイズの 1bppフォーマット のスプライトのデータをマージして 2bppとし sSpriteBuffer2 の終端から sSpriteBuffer1 の先頭まで配置する  
; sSpriteBuffer1 と sSpriteBuffer2 は連続していてサイズはともに SPRITEBUFFERSIZE なので sSpriteBuffer2 の終端から配置していけば sSpriteBuffer1 の先頭で終わる  
; 
; INPUT: de = output address  
InterlaceMergeSpriteBuffers::
	; ROMバンクを0にする
	xor a
	ld [$4000], a

	push de

	ld hl, sSpriteBuffer2 + (SPRITEBUFFERSIZE - 1) ; destination: end of buffer 2
	ld de, sSpriteBuffer1 + (SPRITEBUFFERSIZE - 1) ; source 2: end of buffer 1
	ld bc, sSpriteBuffer0 + (SPRITEBUFFERSIZE - 1) ; source 1: end of buffer 0

	; .interlaceLoop のループ回数 = SPRITEBUFFERSIZE/2
	ld a, SPRITEBUFFERSIZE/2 ; $c4
	ld [H_SPRITEINTERLACECOUNTER], a
	; 後ろの方から sSpriteBuffer0 と sSpriteBuffer1にある 1bppのデータを交互に sSpriteBuffer2に配置していく
	; 1ループで 4バイト処理するので合計で SPRITEBUFFERSIZE * 2バイトを配置するため、sSpriteBuffer2の終端から sSpriteBuffer1の先頭まで配置される
.interlaceLoop
	; source 2 から destination に 1バイト
	ld a, [de]
	dec de
	ld [hld], a   ; [hl--] = [de--]
	
	; source 1 から destination に 1バイト
	ld a, [bc]
	dec bc
	ld [hld], a   ; [hl--] = [bc--]
	
	; source 2 から destination に 1バイト
	ld a, [de]
	dec de
	ld [hld], a  ; [hl--] = [de--] 
	
	; source 1 から destination に 1バイト
	ld a, [bc]
	dec bc
	ld [hld], a   ; [hl--] = [bc--]
	
	; 次のループへ
	ld a, [H_SPRITEINTERLACECOUNTER]
	dec a
	ld [H_SPRITEINTERLACECOUNTER], a
	jr nz, .interlaceLoop

	; 対象のスプライトが左右反転したものでない -> .notFlipped
	ld a, [wSpriteFlipped]
	and a
	jr z, .notFlipped

	; 反転している場合はすべてのバイトのニブルを反転させる (XXXXYYYY -> YYYYXXXX)
	ld bc, 2*SPRITEBUFFERSIZE
	ld hl, sSpriteBuffer1
.swapLoop
	swap [hl]    
	inc hl
	dec bc
	ld a, b
	or c
	jr nz, .swapLoop

.notFlipped
	; [H_LOADEDROMBANK] の sSpriteBuffer1 から output address に 49タイルだけコピー
	pop hl ; hl = output address
	ld de, sSpriteBuffer1
	ld c, (2*SPRITEBUFFERSIZE)/16 ; $31=49, number of 16 byte chunks to be copied
	ld a, [H_LOADEDROMBANK]
	ld b, a
	jp CopyVideoData


INCLUDE "data/collision.asm"
INCLUDE "home/copy2.asm"
INCLUDE "home/text.asm"
INCLUDE "home/vcopy.asm"
INCLUDE "home/init.asm"
INCLUDE "home/vblank.asm"
INCLUDE "home/fade.asm"
INCLUDE "home/serial.asm"
INCLUDE "home/timer.asm"
INCLUDE "home/audio.asm"


; **UpdateSprites**  
; スプライトの更新処理を行う関数  
; - - -  
; c1X0のすべてのスプライトの1コマ分の更新処理を行う  
; 
; 更新処理:  
; プレイヤーの場合は、現在の状況に応じて1コマ進める  
; NPCの場合は、NPCの 移動方向決定+移動開始の1コマ または 歩きモーションを1コマ進める処理 を行う 
UpdateSprites::
	; wUpdateSpritesEnabledが$00か$ffのときは何もしない
	ld a, [wUpdateSpritesEnabled]
	dec a
	ret nz

	; _UpdateSpritesのためにバンク切り替え
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, Bank(_UpdateSprites)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	call _UpdateSprites

	; 元のバンクに復帰
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

INCLUDE "data/mart_inventories.asm"

TextScriptEndingChar::
	db "@"
TextScriptEnd::
	ld hl, TextScriptEndingChar
	ret

; "!"
ExclamationText::
	TX_FAR _ExclamationText
	db "@"

; "Ground rose up somewhere!"
GroundRoseText::
	TX_FAR _GroundRoseText
	db "@"

; "This requires STRENGTH to move!"
BoulderText::
	TX_FAR _BoulderText
	db "@"

; "All your item needs fulfilled! #MON MART"
MartSignText::
	TX_FAR _MartSignText
	db "@"

; "Heal Your #MON! #MON CENTER"
PokeCenterSignText::
	TX_FAR _PokeCenterSignText
	db "@"

PickUpItemText::
	TX_ASM
	predef PickUpItem
	jp TextScriptEnd


INCLUDE "home/pic.asm"

; **ResetPlayerSpriteData**  
; 主人公のスプライトデータを初期化する
ResetPlayerSpriteData::
	; 主人公のスプライトデータを0クリア
	ld hl, wSpriteStateData1
	call ResetPlayerSpriteData_ClearSpriteData
	ld hl, wSpriteStateData2
	call ResetPlayerSpriteData_ClearSpriteData
	; 主人公なので 0xc100 と 0xc20eは1
	ld a, $1
	ld [wSpriteStateData1], a
	ld [wSpriteStateData2 + $0e], a
	; 主人公の初期値(自分の部屋)の座標を設定
	ld hl, wSpriteStateData1 + 4
	ld [hl], $3c     ; set Y screen pos
	inc hl
	inc hl
	ld [hl], $40     ; set X screen pos
	ret

; 主人公のスプライトデータを0クリアする  
; INPUT: hl = wSpriteStateData1(0xc100) or wSpriteStateData2(0xc200)
ResetPlayerSpriteData_ClearSpriteData::
	ld bc, $10
	xor a
	jp FillMemory ; return

; **FadeOutAudio**  
; VBlankごとに 音楽の fadeout 処理  
FadeOutAudio::
	; [wAudioFadeOutControl] > 0 なら fadeout 処理をする  -> .fadingOut
	ld a, [wAudioFadeOutControl]
	and a
	jr nz, .fadingOut

; fadeout せず問答無用で音楽をストップする 
	; wd72c[1] が立っているなら何もせず終了
	ld a, [wd72c]
	bit 1, a
	ret nz
	; 音量を 0 にして fadeout処理を完了する
	ld a, $77	; b01110111 = 左右の音量 0
	ld [rNR50], a
	ret

; fadeout処理
.fadingOut
	; [wAudioFadeOutCounter] == 0 -> .counterReachedZero
	ld a, [wAudioFadeOutCounter]
	and a
	jr z, .counterReachedZero

	; [wAudioFadeOutCounter]--
	dec a
	ld [wAudioFadeOutCounter], a
	ret

; [wAudioFadeOutCounter] が 0 になったとき
; 音量を 1だけ下げる
.counterReachedZero
	; [wAudioFadeOutCounter] に reload用の値をセット
	ld a, [wAudioFadeOutCounterReloadValue]
	ld [wAudioFadeOutCounter], a

	; 音量がすでに 0 つまり 完全に音楽が fadeoutした -> .fadeOutComplete
	ld a, [rNR50]
	and a
	jr z, .fadeOutComplete

	ld b, a ; b = [rNR50]
	and $f
	dec a
	ld c, a	; c = ([rNR50]の下位ニブル) - 1

	ld a, b
	and $f0
	swap a
	dec a	; a = ([rNR50]の上位ニブル) - 1

	; [rNR50] = ([rNR50]の上位ニブル) - 1 << 4 | ([rNR50]の下位ニブル) - 1
	; つまり　左右の音量を 1ずつ下げる
	swap a
	or c
	ld [rNR50], a
	ret

.fadeOutComplete
	; [wAudioFadeOutControl] = 0
	; b = 次に再生する音楽のID (0にする前の[wAudioFadeOutControl])
	ld a, [wAudioFadeOutControl]
	ld b, a
	xor a
	ld [wAudioFadeOutControl], a

	; 音楽の再生を止める(音量を0にするのとは別に)
	ld a, $ff
	ld [wNewSoundID], a
	call PlaySound

	; 次の音楽の再生を開始する
	ld a, [wAudioSavedROMBank]
	ld [wAudioROMBank], a
	ld a, b
	ld [wNewSoundID], a
	jp PlaySound


; **DisplayTextID**  
; テキストID　に対応するテキストを表示する  
; - - -  
; signメッセージやスプライトのダイアログ表示などで利用される  
; スプライトのオフセット がテキストIDとしてわたされたときはそのスプライトが保持しているTextIDのテキストを表示する  
; 
; INPUT: [hSpriteIndexOrTextID] = スプライトのオフセット or テキストID  
DisplayTextID::
	ld a, [H_LOADEDROMBANK]
	push af
	callba DisplayTextIDInit ; initialization

	; wTextPredefFlag[0]がセットされているなら 現在のマップデータが格納されているバンクにスイッチ
	ld hl, wTextPredefFlag
	bit 0, [hl]
	res 0, [hl]				; wTextPredefFlag[0]はクリアしておく
	jr nz, .skipSwitchToMapBank
	ld a, [wCurMap]
	call SwitchToMapRomBank

.skipSwitchToMapBank
	ld a, 30 ; half a second
	ld [H_FRAMECOUNTER], a ; used as joypad poll timer

	; hl = 現在のマップのテキストテーブル
	ld hl, wMapTextPtr
	inline "hl = [hl]"

	ld d, $00

	; 特殊なテキスト描画処理でないか検討
	ld a, [hSpriteIndexOrTextID] 	; TextID or スプライトオフセット
	ld [wSpriteIndex], a			; 話しかけたスプライトのスプライトオフセット
	SWITCH $00, DisplayStartMenu
	SWITCH TEXT_SAFARI_GAME_OVER, DisplaySafariGameOverText
	SWITCH TEXT_MON_FAINTED, DisplayPokemonFaintedText
	SWITCH TEXT_BLACKED_OUT, DisplayPlayerBlackedOutText
	SWITCH TEXT_REPEL_WORE_OFF, DisplayRepelWoreOffText

	; [hSpriteIndexOrTextID] が 
	; スプライトのオフセット -> .spriteHandling ([hSpriteIndexOrTextID] <= スプライトの数)
	; テキストID -> .skipSpriteHandling ([hSpriteIndexOrTextID] > スプライトの数)
	ld a, [wNumSprites]
	ld e, a
	ld a, [hSpriteIndexOrTextID] ; sprite ID
	cp e
	jr z, .spriteHandling
	jr nc, .skipSpriteHandling

; スプライトのテキストIDを取得
.spriteHandling
	push hl

	; プレイヤーが話しかけたスプライトのグラフィックを更新 (to face the right direction)
	push de
	push bc
	callba UpdateSpriteFacingOffsetAndDelayMovement
	pop bc
	pop de

	; a = 対象のスプライトのテキストID
	ld hl, wMapSpriteData ; NPC text entries
	ld a, [hSpriteIndexOrTextID]
	dec a				  ; プレイヤーの分デクリメント
	add a				  ; wMapSpriteDataは各エントリ2バイトなので
	add l
	ld l, a
	jr nc, .noCarry
	inc h
.noCarry
	; この時点で hl = wMapSpriteData[hSpriteIndexOrTextID-1]
	inc hl
	ld a, [hl] ; a = スプライトの text ID
	pop hl

; テキストテーブル の中から対象のテキストのアドレスを探す  
; a = テキストID
; hl = テキストテーブル(e.g. PalletTown_TextPointers)
.skipSpriteHandling
	; hl = (textID-1)*2 + マップのテキストエントリ
	dec a
	ld e, a
	sla e
	add hl, de

	; hl = テキストIDに対応するテキストがあるアドレス
	inline "hl = [hl]"
	ld a, [hl] ; a = テキストの1バイト目
	
	; 最初の1バイト目を見て特殊なテキストであるならそのハンドラにジャンプ
	; PokemartのNPC
	cp $fe
	jp z, DisplayPokemartDialogue

	; Pokemon CenterのNPC
	cp $ff   
	jp z, DisplayPokemonCenterDialogue

	; Item Storage PC
	cp $fc
	jp z, FuncTX_ItemStoragePC

	; Bill's PC
	cp $fd
	jp z, FuncTX_BillsPC

	; ポケモンセンターのPC
	cp $f9
	jp z, FuncTX_PokemonCenterPC

	; 自動販売機で"ない"
	cp $f5
	jr nz, .notVendingMachine

	; 自動販売機
	callba VendingMachineMenu ; jump banks to vending machine routine
	jr AfterDisplayingTextID

; 自動販売機ではないが特殊なテキスト
.notVendingMachine
	; ゲームコーナーの景品
	cp $f7   ; prize menu
	jp z, FuncTX_GameCornerPrizeMenu

	; ケーブルクラブではない => 普通のテキスト
	cp $f6   ; cable connection NPC in Pokemon Center
	jr nz, .notSpecialCase

	; ケーブルクラブ
	callab CableClubNPC
	jr AfterDisplayingTextID

; 普通のテキストの場合
.notSpecialCase
	call PrintText_NoCreatingTextBox ; display the text

	; テキストがボタンを押さなくても次に進んでいく場合
	ld a, [wDoNotWaitForButtonPressAfterDisplayingText]
	and a
	jr nz, HoldTextDisplayOpen

AfterDisplayingTextID::
	; ???
	ld a, [wEnteringCableClub]
	and a
	jr nz, HoldTextDisplayOpen

	call WaitForTextScrollButtonPress ; テキストがすべて表示された後でAボタンが押されるまで待機

; loop to hold the dialogue box open as long as the player keeps holding down the A button
; プレイヤーがAボタンを押し続けている限りダイアログボックスを表示し続ける
HoldTextDisplayOpen::
	call Joypad
	ld a, [hJoyHeld]
	bit 0, a ; is the A button being pressed?
	jr nz, HoldTextDisplayOpen

; **CloseTextDisplay**  
; テキスト表示を終える  
; - - -  
; ウィンドウとして存在していたテキストボックスを消し、マップの状態を復元  
; どんなテキストボックスでも対応可能  
CloseTextDisplay::
	; 現在のマップの Map Headerのあるバンクにスイッチ
	ld a, [wCurMap]
	call SwitchToMapRomBank

	; ウィンドウを非表示に
	ld a, $90
	ld [hWY], a
	call DelayFrame

	; パレットを通常時に戻す
	call LoadGBPal

	; VBlank期間の自動的なBG転送を無効に
	xor a
	ld [H_AUTOBGTRANSFERENABLED], a ; disable continuous WRAM to VRAM transfer each V-blank
	
; すべてのスプライトが会話前に向いていた方向を向くようにする
	ld hl, wSpriteStateData2 + $19
	ld c, $0f
	ld de, $0010
.restoreSpriteFacingDirectionLoop
	ld a, [hl]
	dec h
	ld [hl], a
	inc h
	add hl, de
	dec c
	jr nz, .restoreSpriteFacingDirectionLoop
	ld a, BANK(InitMapSprites)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call InitMapSprites ; reload sprite tile pattern data (since it was partially overwritten by text tile patterns)
	ld hl, wFontLoaded
	res 0, [hl]
	ld a, [wd732]
	bit 3, a ; used fly warp
	call z, LoadPlayerSpriteGraphics
	call LoadCurrentMapView
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	jp UpdateSprites	; return

DisplayPokemartDialogue::
	push hl
	ld hl, PokemartGreetingText
	call PrintText
	pop hl
	inc hl
	call LoadItemList
	ld a, PRICEDITEMLISTMENU
	ld [wListMenuID], a
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, Bank(DisplayPokemartDialogue_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call DisplayPokemartDialogue_
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	jp AfterDisplayingTextID

PokemartGreetingText::
	TX_FAR _PokemartGreetingText
	db "@"

LoadItemList::
	ld a, 1
	ld [wUpdateSpritesEnabled], a
	ld a, h
	ld [wItemListPointer], a
	ld a, l
	ld [wItemListPointer + 1], a
	ld de, wItemList
.loop
	inline "[de++] = [hl++]"
	cp $ff
	jr nz, .loop
	ret

DisplayPokemonCenterDialogue::
; zeroing these doesn't appear to serve any purpose
	xor a
	ld [$ff8b], a
	ld [$ff8c], a
	ld [$ff8d], a

	inc hl
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, Bank(DisplayPokemonCenterDialogue_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call DisplayPokemonCenterDialogue_
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	jp AfterDisplayingTextID

DisplaySafariGameOverText::
	callab PrintSafariGameOverText
	jp AfterDisplayingTextID

; "<POKEMON> fainted!"というテキストを表示する
DisplayPokemonFaintedText::
	ld hl, PokemonFaintedText
	call PrintText
	jp AfterDisplayingTextID

; "<POKEMON> fainted!"
PokemonFaintedText::
	TX_FAR _PokemonFaintedText
	db "@"

DisplayPlayerBlackedOutText::
	ld hl, PlayerBlackedOutText
	call PrintText
	ld a, [wd732]
	res 5, a ; reset forced to use bike bit
	ld [wd732], a
	jp HoldTextDisplayOpen

; "\<PLAYER\> is out of useable #MON!"  
; "\<PLAYER\> blacked out!"  
PlayerBlackedOutText::
	TX_FAR _PlayerBlackedOutText
	db "@"

DisplayRepelWoreOffText::
	ld hl, RepelWoreOffText
	call PrintText
	jp AfterDisplayingTextID

RepelWoreOffText::
	TX_FAR _RepelWoreOffText
	db "@"

INCLUDE "engine/menu/start_menu.asm"

; **CountSetBits**  
; 文字列の各バイトのうち何ビットがセットされているかカウントする関数
; - - -  
; INPUT:  
; hl = 文字列の先頭アドレス  
; b = 文字列の長さ  
; 
; OUTPUT:  
; [wNumSetBits] = セットされたビットの数  
CountSetBits::
	ld c, 0
; 文字列の各文字に対するループ
.loop
	ld a, [hli]
	ld e, a
	ld d, 8
; 文字の各ビットに対するループ
; INPUT:  
; - d = 左から数えて何ビット目か(innerLoopのカウンタ)
; - e = 現在の文字  
.innerLoop
	; c += e[8-d]
	srl e
	ld a, 0
	adc c
	ld c, a

	; 次のbitへ
	dec d
	jr nz, .innerLoop

	; 次の文字へ
	dec b
	jr nz, .loop

	ld a, c
	ld [wNumSetBits], a
	ret

; subtracts the amount the player paid from their money
; sets carry flag if there is enough money and unsets carry flag if not
SubtractAmountPaidFromMoney::
	jpba SubtractAmountPaidFromMoney_

; プレイヤーがアイテムを売却して得たお金を自分の所持金に加える処理  
; INPUT: [hMoney] = 売却額
AddAmountSoldToMoney::
	; 所持金 += 売却額
	ld de, wPlayerMoney + 2
	ld hl, hMoney + 2 ;  売却するアイテム額
	ld c, 3 ; 所持金は3バイトのBCD数値
	predef AddBCDPredef

	; 所持金額が変わったので所持金を表示するテキストボックスを再描画
	ld a, MONEY_BOX
	ld [wTextBoxID], a
	call DisplayTextBoxID ; redraw money text box

	; 売却時のサウンド(チャリン音)
	ld a, SFX_PURCHASE
	call PlaySoundWaitForCurrent
	jp WaitForSoundToFinish

; プレイヤーのかばんかPCから指定した個数だけ指定したアイテムを削除する関数  
; INPUT:  
; HL = 削除対象のインベントリのポインタ(wNumBagItems(かばん) または wNumBoxItems(PC))  
; [wRemoveItemIndex] = 削除する対象のアイテムがインベントリの何番目にあるか  
; [wItemQuantity] = 削除する個数  
RemoveItemFromInventory::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(RemoveItemFromInventory_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call RemoveItemFromInventory_
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **AddItemToInventory**  
; アイテムをプレイヤーのバッグかPCボックスに追加する関数(個数は問わない)  
; - - - 
; 内部で AddItemToInventory_ を呼び出しているだけ  
; 成功したときにはcarryをセット、失敗したときにはcarryをクリアする  
; INPUT:  
; - HL = インベントリのアドレス (wNumBagItems  or wNumBoxItems)  
; - [wcf91] = アイテムID  
; - [wItemQuantity] = アイテムの個数  
AddItemToInventory::
	push bc
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(AddItemToInventory_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call AddItemToInventory_
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	pop bc
	ret

; **DisplayListMenuID**  
; list menuのテキストボックスを表示して DisplayListMenuIDLoop  
; - - -  
; この関数では listのテキストボックスの枠や中身も表示する  
; 
; INPUT:  
; [wListMenuID] = list menu ID  
; [wListPointer] = listのポインタ(2バイト)  
; 
; OUTPUT:  
; 
DisplayListMenuID::
	; 自動的なBG転送を無効化
	xor a
	ld [H_AUTOBGTRANSFERENABLED], a ; disable auto-transfer

	ld a, 1
	ld [hJoy7], a ; joypad state update flag

; 通常バトルなら バンク 1 に	
; トキワシティの老人のポケモン捕獲バトル or サファリゾーンのバトル なら BANK(DisplayBattleMenu) にスイッチ
	ld a, [wBattleType]
	and a
	jr nz, .specialBattleType
	ld a, $01
	jr .bankswitch
.specialBattleType
	ld a, BANK(DisplayBattleMenu)
.bankswitch
	call BankswitchHome

	; テキスト表示時の遅延をoff
	ld hl, wd730
	set 6, [hl]
	
	; リストに関する変数を0クリア
	xor a
	ld [wMenuItemToSwap], a ; どのアイテムもセレクトで順番入れ替えのために選択されている状態にない
	ld [wListCount], a		; listの要素数が0

	; hl = menuの項目を表す list のポインタ
	ld a, [wListPointer]
	ld l, a
	ld a, [wListPointer + 1]
	ld h, a

	; [wListCount] = menu の項目数
	ld a, [hl]			; list の最初のエントリは項目数
	ld [wListCount], a

	; list menuのテキストボックスを表示
	ld a, LIST_MENU_BOX
	ld [wTextBoxID], a
	call DisplayTextBoxID ; draw the menu text box

	call UpdateSprites	; テキストボックスに隠れたスプライトを非表示にする
	
; ここから.skipMovingSpritesまでのコードは意味がなさそうに見える
	coord hl, 4, 2 ; coordinates of upper left corner of menu text box
	lb de, 9, 14 ; height and width of menu text box
	ld a, [wListMenuID]
	and a ; is it a PC pokemon list?
	jr nz, .skipMovingSprites
	call UpdateSprites

.skipMovingSprites
	; menuのwrappingを無効に
	ld a, 1
	ld [wMenuWatchMovingOutOfBounds], a
	
	; [wMaxMenuItem] = a(a <= 1) or 2 つまり [wMaxMenuItem]は最大で2(list menuは4番目(index:3)以降は下にスクロールするので)
	ld a, [wListCount]
	cp 2
	jr c, .setMenuVariables	; 2 > a
	ld a, 2
.setMenuVariables
	ld [wMaxMenuItem], a

	; カーソルの位置を (5, 4) に
	ld a, 4
	ld [wTopMenuItemY], a
	ld a, 5
	ld [wTopMenuItemX], a

	; (上下方向キーのぞいて)A/B/Selectボタンのみ有効
	ld a, A_BUTTON | B_BUTTON | SELECT
	ld [wMenuWatchedKeys], a
	ld c, 10
	call DelayFrames	; fallthrough

; **DisplayListMenuIDLoop**  
; list menu でユーザーの入力を待って対応する処理  
; - - -  
; INPUT:  
; [wListMenuID] = PCPOKEMONLISTMENU or PRICEDITEMLISTMENU or ITEMLISTMENU  
; 
; OUTPUT:  
; carry = 0(選択された) or 1(キャンセルされた)  
; 
; Aボタンが押された時の OUTPUT  
; [wMenuExitMethod] = CHOSE_MENU_ITEM  
; [wcf91] = ItemID or PokemonID  
; [wcf4b] = アイテム名 or ポケモン名  
DisplayListMenuIDLoop::
	; list menuをテキストボックス内に表示 
	xor a
	ld [H_AUTOBGTRANSFERENABLED], a
	call PrintListMenuEntries
	ld a, 1
	ld [H_AUTOBGTRANSFERENABLED], a ; enable transfer
	call Delay3

	; トキワシティの老人によるポケモン捕獲デモ -> .notOldManBattle
	ld a, [wBattleType]
	and a
	jr z, .notOldManBattle

.oldManBattle
	; モンスターボール×50 にカーソルを合わせ選択されたことにする -> .buttonAPressed

	; モンスターボール×50 にカーソル
	ld a, "▶"
	Coorda 5, 4
	ld c, 80
	call DelayFrames
	xor a
	ld [wCurrentMenuItem], a

	; [wMenuCursorLocation] = (5, 4)
	coord hl, 5, 4
	ld a, l
	ld [wMenuCursorLocation], a
	ld a, h
	ld [wMenuCursorLocation + 1], a
	jr .buttonAPressed

.notOldManBattle
	call LoadGBPal
	call HandleMenuInput
	push af
	call PlaceMenuCursor
	pop af
	bit 0, a
	jp z, .checkOtherKeys
	; Aボタン -> .buttonAPressed(fallthrough)

.buttonAPressed
	; 選択した項目のカーソルを白抜き▷に
	ld a, [wCurrentMenuItem]
	call PlaceUnfilledArrowMenuCursor

	; この3行は無駄なコード
	ld a, $01
	ld [wMenuExitMethod], a
	ld [wChosenMenuItem], a

	xor a
	ld [wMenuWatchMovingOutOfBounds], a

	; c = 選んだ項目の list menu全体でのオフセット
	ld a, [wCurrentMenuItem]
	ld c, a
	ld a, [wListScrollOffset]
	add c
	ld c, a

	; list menu の空白の領域を選択(バグ対策?) -> ExitListMenu
	ld a, [wListCount]
	and a
	jp z, ExitListMenu

	; やめるなどの一番下の番兵を選択 -> ExitListMenu
	dec a
	cp c
	jp c, ExitListMenu

	; [wListMenuOffset] = 選んだ項目の list menu全体でのオフセット
	ld a, c
	ld [wListMenuOffset], a

	; list menuの内容が アイテム以外 -> .skipMultiplying
	ld a, [wListMenuID]
	cp ITEMLISTMENU
	jr nz, .skipMultiplying

	; アイテムのlist menuのとき、listの各エントリは2byteなので *2
	sla c
.skipMultiplying

	; hl = 選んだ項目の list のエントリのアドレス
	ld a, [wListPointer]
	ld l, a
	ld a, [wListPointer + 1]
	ld h, a
	inc hl
	ld b, 0
	add hl, bc

	; [wcf91] = 選んだエントリのアイテムID(ITEMLISTMENU -> ItemID, PCPOKEMONLISTMENU -> PokemonID, ...)
	ld a, [hl]
	ld [wcf91], a

	; list menu がポケモンのリスト -> .pokemonList
	ld a, [wListMenuID]
	and a ; PCPOKEMONLISTMENU
	jr z, .pokemonList

	; ここにくるのはアイテムのリストの場合なので値段を入手
	push hl
	call GetItemPrice
	pop hl
	
	; PRICEDITEMLISTMENU -> .skipGettingQuantity
	ld a, [wListMenuID]
	cp ITEMLISTMENU
	jr nz, .skipGettingQuantity

	; アイテムのlist menuのとき、エントリの2byte目からかばんの個数をとる
	inc hl
	ld a, [hl] ; a = item quantity
	ld [wMaxItemQuantity], a

; [wcf4b] = アイテム名 or ポケモン名
.skipGettingQuantity
	ld a, [wcf91]
	ld [wd0b5], a	; [wd0b5] = アイテムID
	ld a, BANK(ItemNames)
	ld [wPredefBank], a
	call GetName
	jr .storeChosenEntry
.pokemonList
	ld hl, wPartyCount
	ld a, [wListPointer]
	cp l ; is it a list of party pokemon or box pokemon?
	ld hl, wPartyMonNicks
	jr z, .getPokemonName
	ld hl, wBoxMonNicks ; box pokemon names
.getPokemonName
	ld a, [wListMenuOffset]
	call GetPartyMonName
.storeChosenEntry ; store the menu entry that the player chose and return
	ld de, wcd6d
	call CopyStringToCF4B ; copy name to wcf4b

	; 選択結果を WRAM に書き込む
	ld a, CHOSE_MENU_ITEM
	ld [wMenuExitMethod], a	; [wMenuExitMethod] = CHOSE_MENU_ITEM
	ld a, [wCurrentMenuItem]
	ld [wChosenMenuItem], a	; [wChosenMenuItem] = [wCurrentMenuItem]

	; 終了
	xor a
	ld [hJoy7], a ; joypad state update flag
	ld hl, wd730
	res 6, [hl] ; turn on letter printing delay
	jp BankswitchBack	; return

; B/Select/↑/↓ が押された時はここにくる
.checkOtherKeys
	; B -> ExitListMenu
	bit 1, a
	jp nz, ExitListMenu

	; Select -> HandleItemListSwapping
	bit 2, a
	jp nz, HandleItemListSwapping

	; ↑ -> .upPressed
	ld b, a
	bit 7, b ; was Down pressed?
	ld hl, wListScrollOffset
	jr z, .upPressed
	; ↓ -> .downPressed(fallthrough)

.downPressed
	; CANCELボタンが見えている -> wListScrollOffsetそのまま
	ld a, [hl]
	add 3
	ld b, a
	ld a, [wListCount]
	cp b ; will going down scroll past the Cancel button?
	jp c, DisplayListMenuIDLoop

	; wListScrollOffset++
	inc [hl] ; if not, go down
	jp DisplayListMenuIDLoop	; loop

.upPressed
	ld a, [hl]
	and a
	jp z, DisplayListMenuIDLoop
	dec [hl]
	jp DisplayListMenuIDLoop

; **DisplayChooseQuantityMenu**  
; 個数を選択するメニューを表示
; - - - 
; 
; OUTPUT:  
; a = $00(Aボタン) or $ff(Bボタン)  
; [wItemQuantity] = 売却個数  
DisplayChooseQuantityMenu::
	; メニューのテキストボックスの大きさを設定する
	; PRICEDITEMLISTMENUでないなら個数を表示するメニューでok
	coord hl, 15, 9
	ld b, 1 ; height
	ld c, 3 ; width
	ld a, [wListMenuID]
	cp PRICEDITEMLISTMENU
	jr nz, .drawTextBox
	
	; PRICEDITEMLISTMENUは個数と価格を表示するメニューを表示する必要があるので大きめにする
	coord hl, 7, 9
	ld b, 1  ; height
	ld c, 11 ; width

	; テキストボックスを描画
.drawTextBox
	call TextBoxBorder

	; テキスト配置先のアドレスを決定
	coord hl, 16, 10	; PRICEDITEMLISTMENUのとき
	ld a, [wListMenuID]
	cp PRICEDITEMLISTMENU
	jr nz, .printInitialQuantity
	coord hl, 8, 10		; それ以外

	; 個数のテキスト(×01)を表示
.printInitialQuantity
	ld de, InitialQuantityText
	call PlaceString

	; [wItemQuantity] = 0
	xor a
	ld [wItemQuantity], a
	jp .incrementQuantity

.waitForKeyPressLoop
	call JoypadLowSensitivity
	ld a, [hJoyPressed] ; newly pressed buttons
	
	; Aボタン
	bit 0, a
	jp nz, .buttonAPressed
	
	; Bボタン
	bit 1, a
	jp nz, .buttonBPressed
	
	; 上ボタン
	bit 6, a
	jr nz, .incrementQuantity
	
	; 下ボタン
	bit 7, a
	jr nz, .decrementQuantity
	
	jr .waitForKeyPressLoop

.incrementQuantity
	ld a, [wMaxItemQuantity]
	inc a
	ld b, a						; b = [wMaxItemQuantity] + 1 = 指定できる最大の数 + 1
	ld hl, wItemQuantity
	inc [hl]
	ld a, [hl]					; a = [wItemQuantity] + 1 = 現在指定している個数+1
	cp b
	jr nz, .handleNewQuantity	; a != b => つまり現在指定している個数+1以上のアイテムを指定できる

	; 現在指定している個数+1以上のアイテムを指定できないときは1に戻す
	ld a, 1
	ld [hl], a
	jr .handleNewQuantity
.decrementQuantity
	ld hl, wItemQuantity ; current quantity
	dec [hl]
	jr nz, .handleNewQuantity	; 指定している個数を1減らす

	; 現在している個数-1が-1になるときは指定できる最大の数にする
	ld a, [wMaxItemQuantity]
	ld [hl], a

	; INPUT:
	; - [wItemQuantity] = 新しく指定することになる個数
.handleNewQuantity
	; PRICEDITEMLISTMENU でないときは個数のみを表示
	coord hl, 17, 10
	ld a, [wListMenuID]
	cp PRICEDITEMLISTMENU
	jr nz, .printQuantity

	; PRICEDITEMLISTMENU のとき
.printPrice
	ld c, $03
	ld a, [wItemQuantity]
	ld b, a	; bc = [wItemQuantity] : 03
	ld hl, hMoney ; total price
	
	; [hMoney] = 0
	xor a
	ld [hli], a
	ld [hli], a
	ld [hl], a
.addLoop ; loop to multiply the individual price by the quantity to get the total price
	; hMoney = hMoney + hItemPrice
	ld de, hMoney + 2
	ld hl, hItemPrice + 2
	push bc
	predef AddBCDPredef
	pop bc
	dec b
	jr nz, .addLoop

	; アイテムの値段を半分にする必要があるか？(プレイヤーが売るとき)
	ld a, [hHalveItemPrices]
	and a
	jr z, .skipHalvingPrice

	; プレイヤーが売るとき、値段を半分にする処理
	xor a
	ld [hDivideBCDDivisor], a
	ld [hDivideBCDDivisor + 1], a
	ld a, $02
	ld [hDivideBCDDivisor + 2], a
	predef DivideBCDPredef3 ; hDivideBCDQuotient = hMoney ÷ hDivideBCDBuffer  	
	ld a, [hDivideBCDQuotient]
	ld [hMoney], a
	ld a, [hDivideBCDQuotient + 1]
	ld [hMoney + 1], a
	ld a, [hDivideBCDQuotient + 2]
	ld [hMoney + 2], a

.skipHalvingPrice
	; スペーサーを表示(個数はまだ表示してないが、 個数 -> スペーサー -> 価格 となる配置にする)
	coord hl, 12, 10
	ld de, SpacesBetweenQuantityAndPriceText
	call PlaceString

	; 価格を表示
	ld de, hMoney ; total price
	ld c, $a3
	call PrintBCDNumber

	; 個数を表示するためのタイルアドレス
	coord hl, 9, 10

	; 個数を表示
.printQuantity
	ld de, wItemQuantity ; current quantity
	lb bc, LEADING_ZEROES | 1, 2 ; 1 byte, 2 digits
	call PrintNumber
	; キー入力を待つ
	jp .waitForKeyPressLoop

.buttonAPressed ; the player chose to make the transaction
	xor a
	ld [wMenuItemToSwap], a ; 0 means no item is currently being swapped
	ret
	
.buttonBPressed ; the player chose to cancel the transaction
	xor a
	ld [wMenuItemToSwap], a ; 0 means no item is currently being swapped
	ld a, $ff
	ret

InitialQuantityText::
	db "×01@"

SpacesBetweenQuantityAndPriceText::
	db "      @"

ExitListMenu::
	ld a, [wCurrentMenuItem]
	ld [wChosenMenuItem], a
	ld a, CANCELLED_MENU
	ld [wMenuExitMethod], a
	ld [wMenuWatchMovingOutOfBounds], a
	xor a
	ld [hJoy7], a
	ld hl, wd730
	res 6, [hl]
	call BankswitchBack
	xor a
	ld [wMenuItemToSwap], a ; 0 means no item is currently being swapped
	scf
	ret

; **PrintListMenuEntries**  
; list menuを表示する  
; - - -  
; list menuについては`docs/menu.md`を参照  
; 
; INPUT:  
; [wListPointer] = listのポインタ  
PrintListMenuEntries::
	; (5, 3)から9*14タイル分だけクリア
	coord hl, 5, 3
	ld b, 9
	ld c, 14
	call ClearScreenArea

	; de = listの先頭要素
	ld a, [wListPointer]
	ld e, a
	ld a, [wListPointer + 1]
	ld d, a
	inc de

; de = menu画面一番上のアイテムの list のエントリ
	ld a, [wListScrollOffset]
	ld c, a
	ld a, [wListMenuID]
	cp ITEMLISTMENU
	ld a, c
	jr nz, .skipMultiplying	; [wListMenuID] != ITEMLISTMENU => .skipMultiplying
	sla a 	; a *= 2	アイテムリストの各エントリは2バイトなので2倍する
	sla c	; c *= 2	アイテムリストの各エントリは2バイトなので2倍する
.skipMultiplying
	add e
	ld e, a
	jr nc, .noCarry
	inc d
.noCarry

	coord hl, 6, 4 ; (6, 4) = 1項目目のcoord
	ld b, 4 ; list menuに1度に表示できるのは4アイテムまで
.loop
	; [wFourTempCtr] = 4
	ld a, b
	ld [wFourTempCtr], a

	; [wd11e] = menu画面一番上のアイテムのID
	ld a, [de]
	ld [wd11e], a

	; 現在画面一番上に表示されているアイテム が『やめる』の場合 => .printCancelMenuItem
	cp $ff
	jp z, .printCancelMenuItem

	push bc
	push de
	push hl
	push hl
	push de

; ここから .placeNameString までで、 list menu に表示するアイテムの名前を取得している
	ld a, [wListMenuID]
	and a
	jr z, .pokemonPCMenu	; list menuが ポケモン選択リスト の場合 -> .pokemonPCMenu
	cp MOVESLISTMENU
	jr z, .movesMenu		; list menuが 技選択リスト の場合 -> .movesMenu
.itemMenu
	call GetItemName
	jr .placeNameString
.pokemonPCMenu
	push hl
	; hl = wPartyMonNicks or wBoxMonNicks
	ld hl, wPartyCount
	ld a, [wListPointer]
	cp l ; is it a list of party pokemon or box pokemon?
	ld hl, wPartyMonNicks
	jr z, .getPokemonName
	ld hl, wBoxMonNicks ; box pokemon names
.getPokemonName
	; a = 4 - [wFourTempCtr]
	ld a, [wFourTempCtr]
	ld b, a
	ld a, 4	; list menuなのでmax4(パーティ選択ではなくPCBoxのポケモン選択)
	sub b
	; a = [wListScrollOffset] + 4 - [wFourTempCtr] = ポケモンのlist menuでのオフセット
	ld b, a
	ld a, [wListScrollOffset]
	add b
	call GetPartyMonName	; hl += NAME_LENGTH * a
	pop hl
	jr .placeNameString
.movesMenu
	call GetMoveName

; この時点で
	; de => 名前のポインタ
	; hl => リストの配置先のタイルアドレス
.placeNameString
	call PlaceString
	pop de
	pop hl

	; 価格を表示する必要がない場合 -> .skipPrintingItemPrice
	ld a, [wPrintItemPrices]
	and a ; should prices be printed?
	jr z, .skipPrintingItemPrice

.printItemPrice
	; アイテム価格を取得
	push hl
	ld a, [de]
	ld de, ItemPrices
	ld [wcf91], a
	call GetItemPrice ; get price
	pop hl
	; 取得したアイテム価格を表示
	ld bc, SCREEN_WIDTH + 5 ; アイテム名の 1行下,5列右 に価格を表示
	add hl, bc
	ld c, $a3 ; no leading zeroes, right-aligned, print currency symbol, 3 bytes
	call PrintBCDNumber

.skipPrintingItemPrice
	; list menuがポケモン選択でない -> ポケモンのレベル表示処理をスキップ
	ld a, [wListMenuID]
	and a
	jr nz, .skipPrintingPokemonLevel

	; ポケモンのレベル表示処理
.printPokemonLevel
	ld a, [wd11e] ; a = ポケモンのID
	push af
	push hl

	; hl = wPartyCount
	; a = ポケモンのデータが格納されている領域 = PLAYER_PARTY_DATA or BOX_DATA
	ld hl, wPartyCount
	ld a, [wListPointer]
	cp l ; is it a list of party pokemon or box pokemon?
	ld a, PLAYER_PARTY_DATA
	jr z, .next
	ld a, BOX_DATA
.next
	ld [wMonDataLocation], a
	
	; b = 4 - [wFourTempCtr]
	ld hl, wFourTempCtr
	ld a, [hl]
	ld b, a
	ld a, $04
	sub b
	ld b, a

	; [wWhichPokemon] = ポケモンのパーティ/ボックス内のインデックス
	ld a, [wListScrollOffset]
	add b
	ld [hl], a

	; 現在選択中のポケモンのデータを取得
	call LoadMonData

	; パーティのデータのとき -> .skipCopyingLevel
	ld a, [wMonDataLocation]
	and a ; is it a list of party pokemon or box pokemon?
	jr z, .skipCopyingLevel

	; 
.copyLevel
	ld a, [wLoadedMonBoxLevel]
	ld [wLoadedMonLevel], a

.skipCopyingLevel
	pop hl
	ld bc, $001c
	add hl, bc
	call PrintLevel
	pop af
	ld [wd11e], a
.skipPrintingPokemonLevel
	pop hl
	pop de
	inc de
	ld a, [wListMenuID]
	cp ITEMLISTMENU
	jr nz, .nextListEntry
.printItemQuantity
	ld a, [wd11e]
	ld [wcf91], a
	call IsKeyItem ; check if item is unsellable
	ld a, [wIsKeyItem]
	and a ; is the item unsellable?
	jr nz, .skipPrintingItemQuantity ; if so, don't print the quantity
	push hl
	ld bc, SCREEN_WIDTH + 8 ; 1 row down and 8 columns right
	add hl, bc
	ld a, "×"
	ld [hli], a
	ld a, [wd11e]
	push af
	ld a, [de]
	ld [wMaxItemQuantity], a
	push de
	ld de, wd11e
	ld [de], a
	lb bc, 1, 2
	call PrintNumber
	pop de
	pop af
	ld [wd11e], a
	pop hl
.skipPrintingItemQuantity
	inc de
	pop bc
	inc c
	push bc
	inc c
	ld a, [wMenuItemToSwap] ; ID of item chosen for swapping (counts from 1)
	and a ; is an item being swapped?
	jr z, .nextListEntry
	sla a
	cp c ; is it this item?
	jr nz, .nextListEntry
	dec hl
	ld a, "▷" ; unfilled right arrow menu cursor to indicate an item being swapped
	ld [hli], a
.nextListEntry
	ld bc, 2 * SCREEN_WIDTH ; 2 rows
	add hl, bc
	pop bc
	inc c
	dec b
	jp nz, .loop
	ld bc, -8
	add hl, bc
	ld a, "▼"
	ld [hl], a
	ret
.printCancelMenuItem
	ld de, ListMenuCancelText
	jp PlaceString

ListMenuCancelText::
	db "CANCEL@"

; ポケモンの名前を取得する
; 
; INPUT:  
; - [wd11e] = 対象のアイテムID
; 
; OUTPUT:
; - de = ポケモンの名前のポインタ
; - [wcd6d] = ポケモンの名前の文字列データ
GetMonName::
	push hl

	; MonsterNamesのあるバンクにスイッチ
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(MonsterNames)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	; hl = 該当のポケモンの名前のポインタ
	ld a, [wd11e]
	dec a
	ld hl, MonsterNames
	ld c, 10
	ld b, 0
	call AddNTimes

	; wcd6dを使いたいので元のデータを退避
	ld de, wcd6d
	push de

	; [wcd6d:wcd6d+11]に `ポケモン名@`(11文字) を格納
	ld bc, 10
	call CopyData
	ld hl, wcd6d + 10
	ld [hl], "@"

	; 復帰処理をして戻る
	pop de	; de = wcd6d
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	pop hl
	ret

; **GetItemName**  
; 入力で渡した どうぐ のアイテムIDに対応するアイテム名を得る  
; - - -  
; INPUT: [wd11e] = アイテムID  
; 
; OUTPUT: de = アイテム名のポインタ  
GetItemName::
	; starting at wcd6d
	push hl
	push bc

	; アイテムが技マシンのとき
	ld a, [wd11e]
	cp HM_01 ; is this a TM/HM?
	jr nc, .Machine

	; アイテム名をdeに格納
	ld [wd0b5], a
	ld a, ITEM_NAME
	ld [wNameListType], a
	ld a, BANK(ItemNames)
	ld [wPredefBank], a
	call GetName

	jr .Finish

.Machine
	call GetMachineName
.Finish
	ld de, wcd6d ; pointer to where item name is stored in RAM
	pop bc
	pop hl
	ret

GetMachineName::
; copies the name of the TM/HM in [wd11e] to wcd6d
	push hl
	push de
	push bc
	ld a, [wd11e]
	push af
	cp TM_01 ; is this a TM? [not HM]
	jr nc, .WriteTM
; if HM, then write "HM" and add 5 to the item ID, so we can reuse the
; TM printing code
	add 5
	ld [wd11e], a
	ld hl, HiddenPrefix ; points to "HM"
	ld bc, 2
	jr .WriteMachinePrefix
.WriteTM
	ld hl, TechnicalPrefix ; points to "TM"
	ld bc, 2
.WriteMachinePrefix
	ld de, wcd6d
	call CopyData

; now get the machine number and convert it to text
	ld a, [wd11e]
	sub TM_01 - 1
	ld b, "0"
.FirstDigit
	sub 10
	jr c, .SecondDigit
	inc b
	jr .FirstDigit
.SecondDigit
	add 10
	push af
	ld a, b
	ld [de], a
	inc de
	pop af
	ld b, "0"
	add b
	ld [de], a
	inc de
	ld a, "@"
	ld [de], a
	pop af
	ld [wd11e], a
	pop bc
	pop de
	pop hl
	ret

TechnicalPrefix::
	db "TM"
HiddenPrefix::
	db "HM"

; アイテムがHMならcarryを立てる そうでないならcarryをクリア  
; Input: a = アイテムID
IsItemHM::
	cp HM_01
	jr c, .notHM
	cp TM_01
	ret
.notHM
	and a
	ret

; sets carry if move is an HM, clears carry if move is not an HM
; Input: a = move ID
IsMoveHM::
	ld hl, HMMoves
	ld de, 1
	jp IsInArray

HMMoves::
	db CUT,FLY,SURF,STRENGTH,FLASH
	db $ff ; terminator

; **GetMoveName**  
; 技名を取得する  
; - - -
; 
; INPUT:  
; - [wd11e] = アイテムID
; 
; OUTPUT:
; - de = 技名のポインタ
; - [wcd6d] = 技名の文字列データ
GetMoveName::
	push hl
	; GetNameの引数をセット
	ld a, MOVE_NAME
	ld [wNameListType], a
	ld a, [wd11e]
	ld [wd0b5], a
	ld a, BANK(MoveNames)
	ld [wPredefBank], a

	call GetName
	ld de, wcd6d ; pointer to where move name is stored in RAM
	pop hl
	ret

; reloads text box tile patterns, current map view, and tileset tile patterns
ReloadMapData::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, [wCurMap]
	call SwitchToMapRomBank
	call DisableLCD
	call LoadTextBoxTilePatterns
	call LoadCurrentMapView
	call LoadTilesetTilePatternData
	call EnableLCD
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; reloads tileset tile patterns
ReloadTilesetTilePatterns::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, [wCurMap]
	call SwitchToMapRomBank
	call DisableLCD
	call LoadTilesetTilePatternData
	call EnableLCD
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **ChooseFlyDestination**  
; タウンマップを表示して、プレイヤーに空を飛ぶの目的地を選ばせる  
ChooseFlyDestination::
	ld hl, wd72e
	res 4, [hl]
	jpba LoadTownMap_Fly

; causes the text box to close without waiting for a button press after displaying text
DisableWaitingAfterTextDisplay::
	ld a, $01
	ld [wDoNotWaitForButtonPressAfterDisplayingText], a
	ret

; **UseItem**  
; 道具を使う処理  
; - - -  
; UseItem is used with dummy items to perform certain other functions as well
; 
; INPUT:  
; [wcf91] = アイテムID  
; 
; OUTPUT:  
; [wActionResultOrTookBattleTurn] = 結果 0(失敗) or 1(成功) or 2(not able to be used right now, no extra menu displayed (only certain items use this) )  
UseItem::
	jpba UseItem_

; confirms the item toss and then tosses the item
; INPUT:
; hl = address of inventory (either wNumBagItems or wNumBoxItems)
; [wcf91] = item ID
; [wWhichPokemon] = index of item within inventory
; [wItemQuantity] = quantity to toss
; OUTPUT:
; clears carry flag if the item is tossed, sets carry flag if not
TossItem::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(TossItem_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call TossItem_
	pop de
	ld a, d
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; 引数で指定したアイテムがたいせつなものかチェックする  
; INPUT:  
; - [wcf91] = アイテムID
; 
; OUTPUT:  
; - [wIsKeyItem] = 0: たいせつなものでない 1: たいせつなもの  
IsKeyItem::
	push hl
	push de
	push bc
	callba IsKeyItem_
	pop bc
	pop de
	pop hl
	ret

; **DisplayTextBoxID**  
; 引数で与えたTextBox IDに対応するテキストボックスを表示する  
; - - -  
; 使いまわされる定型分的なテキストボックスとテキストなら中のテキストも描画する  
; 
; INPUT:  
; [wTextBoxID] = TextBox ID  
; b, c = カーソルのy, x (2択メニューのみで引数として与える)  
; hl = テキストボックスのボーダーが描画されるべきアドレス  
; [wTwoOptionMenuID] = 2択Menuを表示するなら 2択menu の種類  
DisplayTextBoxID::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(DisplayTextBoxID_)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call DisplayTextBoxID_
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **IsPlayerCharacterBeingControlledByGame**  
; 次のどれかの状態のときに 0 以外の値が返る  
; - - -  
; - NPC movement script が動いている  
; - プレイヤーがドアから出るために自動的に下に進んでいる  
; - simulated joypad  
IsPlayerCharacterBeingControlledByGame::
	; NPC movement script が動いているか
	ld a, [wNPCMovementScriptPointerTableNum]
	and a
	ret nz

	; プレイヤーがドアから出るために自動的に下に進んでいる
	ld a, [wd736]
	bit 1, a ; currently stepping down from door bit
	ret nz

	; simulated joypad
	ld a, [wd730]
	and $80
	ret

; **RunNPCMovementScript**  
; NPC movement scriptを実行する  
; - - -  
; NPC movement script については [update.md](docs/sprite/update.md)参照  
; 
; INPUT:  
; [wNPCMovementScriptPointerTableNum] = 実行対象の NPC movement script を含んだテーブルのオフセット  
; [wNPCMovementScriptFunctionNum] = NPC movement script のテーブルから NPC movement script を選ぶオフセット  
RunNPCMovementScript::
	; wd736[0] を0クリア 0クリア前に1がセットされていたら -> .playerStepOutFromDoor
	ld hl, wd736
	bit 0, [hl]
	res 0, [hl]
	jr nz, .playerStepOutFromDoor

	; NPC movement scriptが実行されていない -> return
	ld a, [wNPCMovementScriptPointerTableNum]	; a = [wNPCMovementScriptPointerTableNum]
	and a
	ret z

	; hl = [wNPCMovementScriptPointerTableNum] に対応する .NPCMovementScriptPointerTables のエントリ
	dec a
	add a
	ld d, 0
	ld e, a	; de = 2(a-1)
	ld hl, .NPCMovementScriptPointerTables
	add hl, de
	
	inline "hl = [hl]"

	; [wNPCMovementScriptBank] にバンクスイッチ
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, [wNPCMovementScriptBank]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	ld a, [wNPCMovementScriptFunctionNum]
	call CallFunctionInTable

	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

.NPCMovementScriptPointerTables
	dw PalletMovementScriptPointerTable
	dw PewterMuseumGuyMovementScriptPointerTable
	dw PewterGymGuyMovementScriptPointerTable

.playerStepOutFromDoor
	jpba PlayerStepOutFromDoor

; **EndNPCMovementScript**  
; scripted NPC と simulated joypad に関する変数やフラグをクリア 
EndNPCMovementScript::
	jpba _EndNPCMovementScript

EmptyFunc2::
	ret

; [wTrainerHeaderPtr] = hl  
StoreTrainerHeaderPointer::
	ld a, h
	ld [wTrainerHeaderPtr], a
	ld a, l
	ld [wTrainerHeaderPtr+1], a
	ret

; **ExecuteCurMapScriptInTable**  
; map scriptをトリガーする関数  
; - - -  
; INPUT:  
; de = map script の jumptable  
; a =  map scriptのインデックス (unless overridden by [wd733] bit 4)  
; hl = trainer header  
ExecuteCurMapScriptInTable::
	push af
	push de
	call StoreTrainerHeaderPointer	; [wTrainerHeaderPtr] = hl
	pop hl	; hl = jumptable
	pop af
	push hl

	; wFlags_D733 の bit4 がセットされている時は Aレジスタで与えられた値を、そうでない場合は[wCurMapScript] をmap scriptのインデックスとして利用する  
	ld hl, wFlags_D733
	bit 4, [hl]
	res 4, [hl]
	jr z, .useProvidedIndex   ; test if map script index was overridden manually
	ld a, [wCurMapScript]

	; jumptableの関数(map script)にジャンプ
.useProvidedIndex
	pop hl	; hl = jumptable
	ld [wCurMapScript], a
	call CallFunctionInTable
	ld a, [wCurMapScript]
	ret

; **LoadGymLeaderAndCityName**  
; wGymCityName と wGymLeaderName に 街の名前とジムリーダーの名前をロードする
; INPUT:  
; hl = 街の名前  
; de = ジムリーダーの名前  
LoadGymLeaderAndCityName::
	push de
	ld de, wGymCityName
	ld bc, $11
	call CopyData   ; load city name
	pop hl
	ld de, wGymLeaderName
	ld bc, NAME_LENGTH
	jp CopyData     ; load gym leader name

; **ReadTrainerHeaderInfo**  
; Trainer Header から 特定の情報を読み取る処理  
; - - -  
; Trainer Header は wTrainerHeaderPtr にアドレスが格納されている  
; Aレジスタの引数に応じて読み取る内容を変える  
; 
; OUTPUT:  
; 呼び出し時 の Aレジスタ が  
;    0 -> [wTrainerHeaderFlagBit] = 撃破フラグのあるbit  
;    2 -> hl = 撃破フラグのあるアドレス  
;    4 -> hl = 戦闘開始前のテキスト  
;    6 -> hl = 戦闘終了後に話しかけた時のテキスト    
;    8 -> hl = 勝利時に戦闘画面で出てくるテキスト  
ReadTrainerHeaderInfo::
	push de
	push af

	; hl = Trainer Header から読み出す内容のアドレス
	ld d, $0
	ld e, a
	ld hl, wTrainerHeaderPtr
	ld a, [hli]
	ld l, [hl]
	ld h, a
	add hl, de

	; a != 0  -> .nonZeroOffset
	pop af
	and a
	jr nz, .nonZeroOffset	; a == 0 のときだけ読み出し先が違うので分岐

	; a == 0 のとき [wTrainerHeaderFlagBit] = 撃破フラグのあるbit
	ld a, [hl]
	ld [wTrainerHeaderFlagBit], a 
	jr .done

	; a != 0 のとき hl = Trainer Header から読み出す内容
.nonZeroOffset

	; a == 2 -> hl = 撃破フラグのあるアドレス
	cp $2
	jr z, .readPointer

	; a == 4 -> hl = 戦闘開始前のテキスト
	cp $4
	jr z, .readPointer

	; a == 6 -> hl = 戦闘終了後に話しかけた時のテキスト
	cp $6
	jr z, .readPointer

	; a == 8 -> hl = 勝利時に戦闘画面で出てくるテキスト
	cp $8
	jr z, .readPointer

	; a != 0xa -> 何もせず return
	cp $a
	jr nz, .done

	; a == 0xa -> de = 勝利時に戦闘画面で出てくるテキスト(2)
	; しかし、 deの内容は .done の `pop de` で上書きされているので無駄なコード バグ?
	ld a, [hli]
	ld d, [hl]
	ld e, a
	jr .done

.readPointer
	inline "hl = [hl]"	; hl = Trainer Header から読み出す内容

.done
	; return 
	pop de
	ret

; **TrainerFlagAction**  
; hlのビットフィールドのビットcにおいてアクションbを実行する  
; - - -  
; INPUT:  
; c = アクション b の対象が hl の何ビット目か  
; b = bitに対してとるアクション(0 -> クリア, 1 -> セット, 2 -> リード)  
; 
; OUTPUT: cレジスタ = アクションの結果(リードなら読み取ったbit)  
TrainerFlagAction::
	predef_jump FlagActionPredef

; **TalkToTrainer**  
; トレーナーと会話をする処理  
; - - -  
; INPUT: hl = Trainer Header(AgathaTrainerHeader0)
TalkToTrainer::
	call StoreTrainerHeaderPointer

	; [wTrainerHeaderFlagBit]に撃破フラグのあるbitを読み出す
	xor a
	call ReadTrainerHeaderInfo

	; hl = 撃破フラグのあるアドレス
	ld a, $2
	call ReadTrainerHeaderInfo
	
	; トレーナーを未撃破 -> .trainerNotYetFought
	ld a, [wTrainerHeaderFlagBit]
	ld c, a
	ld b, FLAG_TEST
	call TrainerFlagAction
	ld a, c
	and a
	jr z, .trainerNotYetFought

	; トレーナーを撃破済みのときは 戦闘終了後に話しかけた時のテキスト を描画して終了
	ld a, $6
	call ReadTrainerHeaderInfo
	jp PrintText	; return

.trainerNotYetFought
	; 戦闘開始前のテキスト
	ld a, $4
	call ReadTrainerHeaderInfo     ; print before battle text
	call PrintText

	; hl = 勝利時に戦闘画面で出てくるテキスト
	ld a, $a
	call ReadTrainerHeaderInfo     ; (?) does nothing apparently (maybe bug in ReadTrainerHeaderInfo)
	push de
	ld a, $8
	call ReadTrainerHeaderInfo     ; read end battle text
	pop de

	call SaveEndBattleTextPointers

	; ExecuteCurMapScriptInTable で Aレジスタによる上書きを許可する
	ld hl, wFlags_D733
	set 4, [hl]                    ; activate map script index override (index is set below)
	
	; プレイヤーが、Map scriptですでにトレーナーに見つかっている場合はreturn
	ld hl, wFlags_0xcd60
	bit 0, [hl]                    ; test if player is already engaging the trainer (because the trainer saw the player)
	ret nz

	; プレイヤーが自分の意志でトレーナーに話しかけた時、[wCurMapScript]++して -> StartTrainerBattle
	call EngageMapTrainer
	ld hl, wCurMapScript
	inc [hl]      ; increment map script index before StartTrainerBattle increments it again (next script function is usually EndTrainerBattle)
	jp StartTrainerBattle

; checks if any trainers are seeing the player and wanting to fight  
; hl = 0番目の Trainer Header (e.g. CeruleanGymTrainerHeader0)
CheckFightingMapTrainers::
	call CheckForEngagingTrainers
	; 
	ld a, [wSpriteIndex]
	cp $ff
	jr nz, .trainerEngaging
	xor a
	ld [wSpriteIndex], a
	ld [wTrainerHeaderFlagBit], a
	ret
.trainerEngaging
	ld hl, wFlags_D733
	set 3, [hl]
	ld [wEmotionBubbleSpriteIndex], a
	xor a ; EXCLAMATION_BUBBLE
	ld [wWhichEmotionBubble], a
	predef EmotionBubble
	ld a, D_RIGHT | D_LEFT | D_UP | D_DOWN
	ld [wJoyIgnore], a
	xor a
	ld [hJoyHeld], a
	call TrainerWalkUpToPlayer_Bank0
	ld hl, wCurMapScript
	inc [hl]      ; increment map script index (next script function is usually DisplayEnemyTrainerTextAndStartBattle)
	ret

; display the before battle text after the enemy trainer has walked up to the player's sprite
DisplayEnemyTrainerTextAndStartBattle::
	ld a, [wd730]
	and $1
	ret nz ; return if the enemy trainer hasn't finished walking to the player's sprite
	ld [wJoyIgnore], a
	ld a, [wSpriteIndex]
	ld [hSpriteIndexOrTextID], a
	call DisplayTextID
	; fall through

StartTrainerBattle::
	xor a
	ld [wJoyIgnore], a
	call InitBattleEnemyParameters
	ld hl, wd72d
	set 6, [hl]
	set 7, [hl]
	ld hl, wd72e
	set 1, [hl]
	ld hl, wCurMapScript
	inc [hl]        ; increment map script index (next script function is usually EndTrainerBattle)
	ret

EndTrainerBattle::
	ld hl, wCurrentMapScriptFlags
	set 5, [hl]
	set 6, [hl]
	ld hl, wd72d
	res 7, [hl]
	ld hl, wFlags_0xcd60
	res 0, [hl]                  ; player is no longer engaged by any trainer

	jpIfInLostBattle ResetButtonPressedAndMapScript

	ld a, $2
	call ReadTrainerHeaderInfo
	ld a, [wTrainerHeaderFlagBit]
	ld c, a
	ld b, FLAG_SET
	call TrainerFlagAction   ; flag trainer as fought
	ld a, [wEnemyMonOrTrainerClass]
	cp OPP_ID_OFFSET
	jr nc, .skipRemoveSprite    ; test if trainer was fought (in that case skip removing the corresponding sprite)
	ld hl, wMissableObjectList
	ld de, $2
	ld a, [wSpriteIndex]
	call IsInArray              ; search for sprite ID
	inc hl
	ld a, [hl]
	ld [wMissableObjectIndex], a               ; load corresponding missable object index and remove it
	predef HideObject
.skipRemoveSprite
	ld hl, wd730
	bit 4, [hl]
	res 4, [hl]
	ret nz

ResetButtonPressedAndMapScript::
	xor a
	ld [wJoyIgnore], a
	ld [hJoyHeld], a
	ld [hJoyPressed], a
	ld [hJoyReleased], a
	ld [wCurMapScript], a               ; reset battle status
	ret

; calls TrainerWalkUpToPlayer
TrainerWalkUpToPlayer_Bank0::
	jpba TrainerWalkUpToPlayer

; sets opponent type and mon set/lvl based on the engaging trainer data
InitBattleEnemyParameters::
	ld a, [wEngagedTrainerClass]
	ld [wCurOpponent], a
	ld [wEnemyMonOrTrainerClass], a
	cp OPP_ID_OFFSET
	ld a, [wEngagedTrainerSet]
	jr c, .noTrainer
	ld [wTrainerNo], a
	ret
.noTrainer
	ld [wCurEnemyLVL], a
	ret

GetSpritePosition1::
	ld hl, _GetSpritePosition1
	jr SpritePositionBankswitch

GetSpritePosition2::
	ld hl, _GetSpritePosition2
	jr SpritePositionBankswitch

SetSpritePosition1::
	ld hl, _SetSpritePosition1
	jr SpritePositionBankswitch

SetSpritePosition2::
	ld hl, _SetSpritePosition2
	; fallthrough

SpritePositionBankswitch::
	ld b, BANK(_GetSpritePosition1) ; BANK(_GetSpritePosition2), BANK(_SetSpritePosition1), BANK(_SetSpritePosition2)
	jp Bankswitch ; indirect jump to one of the four functions


; **CheckForEngagingTrainers**  
; マップ上のトレーナーのどれかに発見されたかチェックする  
; - - -  
; INPUT: hl = 0番目の Trainer Header (e.g. CeruleanGymTrainerHeader0)  
; 
; OUTPUT:  
; [wTrainerSpriteOffset] = 0xff(発見された) or 0x00  
; [wSpriteIndex] = 発見したトレーナー  
CheckForEngagingTrainers::
	; [wTrainerHeaderFlagBit] = 撃破フラグのあるbit, de, hl = Trainer Header
	xor a
	call ReadTrainerHeaderInfo
	ld d, h
	ld e, l

; Trainer Headerを1つずつ見ていく
.trainerLoop
	; [wTrainerHeaderPtr] = 現在処理中のTrainer Header
	call StoreTrainerHeaderPointer

	ld a, [de]
	ld [wSpriteIndex], a                     ; [wSpriteIndex] = 撃破フラグのあるbit
	ld [wTrainerHeaderFlagBit], a

	; 全部見た -> return
	cp $ff
	ret z

	; すでに撃破済み -> .continue
	ld a, $2
	call ReadTrainerHeaderInfo       ; read trainer flag's byte ptr
	ld b, FLAG_TEST
	ld a, [wTrainerHeaderFlagBit]
	ld c, a
	call TrainerFlagAction        ; read trainer flag
	ld a, c
	and a ; has the trainer already been defeated?
	jr nz, .continue

	; トレーナーに発見されたか判定
	push hl
	push de
	push hl
	xor a
	call ReadTrainerHeaderInfo       ; get trainer header pointer
	inc hl
	ld a, [hl]                       ; read trainer engage distance
	pop hl
	ld [wTrainerEngageDistance], a
	ld a, [wSpriteIndex]
	swap a
	ld [wTrainerSpriteOffset], a
	predef TrainerEngage
	pop de
	pop hl

	; 発見されたら return 
	ld a, [wTrainerSpriteOffset]
	and a
	ret nz        ; break if the trainer is engaging

.continue
	; 次のTrainer Headerへ
	ld hl, $c
	add hl, de
	ld d, h
	ld e, l
	jr .trainerLoop

; **SaveEndBattleTextPointers**  
; - - -  
; INPUT:  
; hl = プレイヤーが勝った時のテキスト  
; de = プレイヤーが負けた時のテキスト  
; 
; OUTPUT:  
; [wEndBattleTextRomBank] = テキストのあるバンク  
; [wEndBattleWinTextPointer] = 勝った時のテキスト  
; [wEndBattleLoseTextPointer] = 負けた時のテキスト  
SaveEndBattleTextPointers::
	ld a, [H_LOADEDROMBANK]
	ld [wEndBattleTextRomBank], a
	ld a, h
	ld [wEndBattleWinTextPointer], a
	ld a, l
	ld [wEndBattleWinTextPointer + 1], a
	ld a, d
	ld [wEndBattleLoseTextPointer], a
	ld a, e
	ld [wEndBattleLoseTextPointer + 1], a
	ret

; **EngageMapTrainer**  
; エンカウントしたトレーナーのデータをロードし、エンカウントBGMを流す  
; - - -  
; [wEngagedTrainerClass] と [wEngagedTrainerSet] に wMapSpriteExtraData からエンカウントしたトレーナーのデータをセットする  
; 
; INPUT: [wSpriteIndex] = エンカウントしたトレーナーのスプライトオフセット  
; 
; OUTPUT:  
; [wEngagedTrainerClass] = trainer class  
; [wEngagedTrainerSet] = trainer number  
EngageMapTrainer::
	; hl = wMapSpriteExtraDataの該当エントリ
	ld hl, wMapSpriteExtraData
	ld d, $0
	ld a, [wSpriteIndex]
	dec a
	add a
	ld e, a
	add hl, de

	; [wEngagedTrainerClass] と [wEngagedTrainerSet] に格納
	ld a, [hli]
	ld [wEngagedTrainerClass], a
	ld a, [hl]
	ld [wEngagedTrainerSet], a

	; トレーナーとのエンカウントBGMを流す
	jp PlayTrainerMusic	; return

; **PrintEndBattleText**  
; トレーナーとの戦闘終了後のテキストを描画し、トレーナーを動かなくする  
PrintEndBattleText::
	; 意味なさそう
	push hl
	ld hl, wd72d
	bit 7, [hl]
	res 7, [hl]
	pop hl
	ret z

	; バンクをスイッチ
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, [wEndBattleTextRomBank]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	; トレーナーとの戦闘終了後のテキストを描画
	push hl
	callba SaveTrainerName
	ld hl, TrainerEndBattleText
	call PrintText
	pop hl

	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	callba FreezeEnemyTrainerSprite
	jp WaitForSoundToFinish	; return

; **GetSavedEndBattleTextPointer**  
; OUTPUT: hl = [wEndBattleWinTextPointer] or [wEndBattleLoseTextPointer]  
GetSavedEndBattleTextPointer::
	ld a, [wBattleResult]
	and a
	jr nz, .lostBattle

	; won battle
	ld a, [wEndBattleWinTextPointer]
	ld h, a
	ld a, [wEndBattleWinTextPointer + 1]
	ld l, a
	ret

.lostBattle
	ld a, [wEndBattleLoseTextPointer]
	ld h, a
	ld a, [wEndBattleLoseTextPointer + 1]
	ld l, a
	ret

; **TrainerEndBattleText**  
; トレーナーとの戦闘終了後のテキスト  
TrainerEndBattleText::
	TX_FAR _TrainerNameText
	TX_ASM
	call GetSavedEndBattleTextPointer	; hl = [wEndBattleWinTextPointer] or [wEndBattleLoseTextPointer]
	call TextCommandProcessor
	jp TextScriptEnd

; only engage withe trainer if the player is not already
; engaged with another trainer
; XXX unused?
CheckIfAlreadyEngaged::
	ld a, [wFlags_0xcd60]
	bit 0, a
	ret nz
	call EngageMapTrainer
	xor a
	ret

PlayTrainerMusic::
	ld a, [wEngagedTrainerClass]
	cp OPP_SONY1
	ret z
	cp OPP_SONY2
	ret z
	cp OPP_SONY3
	ret z
	ld a, [wGymLeaderNo]
	and a
	ret nz
	xor a
	ld [wAudioFadeOutControl], a
	ld a, $ff
	call PlaySound
	ld a, BANK(Music_MeetEvilTrainer)
	ld [wAudioROMBank], a
	ld [wAudioSavedROMBank], a
	ld a, [wEngagedTrainerClass]
	ld b, a
	ld hl, EvilTrainerList
.evilTrainerListLoop
	ld a, [hli]
	cp $ff
	jr z, .noEvilTrainer
	cp b
	jr nz, .evilTrainerListLoop
	ld a, MUSIC_MEET_EVIL_TRAINER
	jr .PlaySound
.noEvilTrainer
	ld hl, FemaleTrainerList
.femaleTrainerListLoop
	ld a, [hli]
	cp $ff
	jr z, .maleTrainer
	cp b
	jr nz, .femaleTrainerListLoop
	ld a, MUSIC_MEET_FEMALE_TRAINER
	jr .PlaySound
.maleTrainer
	ld a, MUSIC_MEET_MALE_TRAINER
.PlaySound
	ld [wNewSoundID], a
	jp PlaySound

INCLUDE "data/trainer_types.asm"

; checks if the player's coordinates match an arrow movement tile's coordinates
; and if so, decodes the RLE movement data
; b = player Y
; c = player X
DecodeArrowMovementRLE::
	ld a, [hli]
	cp $ff
	ret z ; no match in the list
	cp b
	jr nz, .nextArrowMovementTileEntry1
	ld a, [hli]
	cp c
	jr nz, .nextArrowMovementTileEntry2
	ld a, [hli]
	ld d, [hl]
	ld e, a
	ld hl, wSimulatedJoypadStatesEnd
	call DecodeRLEList
	dec a
	ld [wSimulatedJoypadStatesIndex], a
	ret
.nextArrowMovementTileEntry1
	inc hl
.nextArrowMovementTileEntry2
	inc hl
	inc hl
	jr DecodeArrowMovementRLE

FuncTX_ItemStoragePC::
	call SaveScreenTilesToBuffer2
	ld b, BANK(PlayerPC)
	ld hl, PlayerPC
	jr bankswitchAndContinue

FuncTX_BillsPC::
	call SaveScreenTilesToBuffer2
	ld b, BANK(BillsPC_)
	ld hl, BillsPC_
	jr bankswitchAndContinue

FuncTX_GameCornerPrizeMenu::
; XXX find a better name for this function
; special_F7
	ld b, BANK(CeladonPrizeMenu)
	ld hl, CeladonPrizeMenu
bankswitchAndContinue::
	call Bankswitch
	jp HoldTextDisplayOpen        ; continue to main text-engine function

FuncTX_PokemonCenterPC::
	ld b, BANK(ActivatePC)
	ld hl, ActivatePC
	jr bankswitchAndContinue

; **StartSimulatingJoypadStates**  
; フラグを立ててsimulated joypad状態にする  
StartSimulatingJoypadStates::
	; ユーザーが勝手に動けないようにする
	xor a
	ld [wOverrideSimulatedJoypadStatesMask], a

	ld [wSpriteStateData2 + $06], a ; playerの "movement byte 1" = 0

	; simulated joypadのフラグを立てる
	ld hl, wd730
	set 7, [hl]
	ret

; **IsItemInBag**  
; - - - 
; bにアイテムIDを指定  
; 指定したアイテムをプレイヤーがかばんに所持してい"ない"ならZフラグをセット、所持しているならZフラグをクリア  
; ポケモンタワーや『ゆうれい』戦に関係
IsItemInBag::
	predef GetQuantityOfItemInBag
	ld a, b
	and a
	ret

; **DisplayPokedex**  
; ポケモン図鑑を表示する
DisplayPokedex::
	ld [wd11e], a
	jpba _DisplayPokedex

SetSpriteFacingDirectionAndDelay::
	call SetSpriteFacingDirection
	ld c, 6
	jp DelayFrames

SetSpriteFacingDirection::
	ld a, $9
	ld [H_SPRITEDATAOFFSET], a
	call GetPointerWithinSpriteStateData1
	ld a, [hSpriteFacingDirection]
	ld [hl], a
	ret

SetSpriteImageIndexAfterSettingFacingDirection::
	ld de, -7
	add hl, de
	ld [hl], a
	ret

; **ArePlayerCoordsInArray**  
; プレイヤーのcoordsが引数で与えられたcoordsのリストに含まれるかチェックする
; - - - 
; INPUT:
; hl = coordsのリスト
; 
; OUTPUT:
; [wCoordIndex] = 該当するcoordsがあるならそのインデックス  
; carry = 該当するcoordsがあるならセットされ、ないならクリアされる
ArePlayerCoordsInArray::
	ld a, [wYCoord]
	ld b, a
	ld a, [wXCoord]
	ld c, a
	; fallthrough

CheckCoords::
	xor a
	ld [wCoordIndex], a
.loop
	ld a, [hli]
	cp $ff ; reached terminator?
	jr z, .notInArray
	push hl
	ld hl, wCoordIndex
	inc [hl]
	pop hl
.compareYCoord
	cp b
	jr z, .compareXCoord
	inc hl
	jr .loop
.compareXCoord
	ld a, [hli]
	cp c
	jr nz, .loop
.inArray
	scf
	ret
.notInArray
	and a
	ret

; tests if a boulder's coordinates are in a specified array
; INPUT:
; hl = address of array
; [H_SPRITEINDEX] = index of boulder sprite
; OUTPUT:
; [wCoordIndex] = if there is match, the matching array index
; sets carry if the coordinates are in the array, clears carry if not
CheckBoulderCoords::
	push hl
	ld hl, wSpriteStateData2 + $04
	ld a, [H_SPRITEINDEX]
	swap a
	ld d, $0
	ld e, a
	add hl, de
	ld a, [hli]
	sub $4 ; because sprite coordinates are offset by 4
	ld b, a
	ld a, [hl]
	sub $4 ; because sprite coordinates are offset by 4
	ld c, a
	pop hl
	jp CheckCoords

GetPointerWithinSpriteStateData1::
	ld h, $c1
	jr _GetPointerWithinSpriteStateData

GetPointerWithinSpriteStateData2::
	ld h, $c2

; INPUT:  
; h = $c1 or $c2($cXYZの X)  
; [H_SPRITEINDEX] = $cXYZの Y  
; [H_SPRITEDATAOFFSET] = $cXYZの Z  
; 
; OUTPUT:  
; hl = $cXYZ  
_GetPointerWithinSpriteStateData:
	ld a, [H_SPRITEDATAOFFSET]
	ld b, a
	ld a, [H_SPRITEINDEX]
	swap a
	add b
	ld l, a
	ret

; **DecodeRLEList**  
; ランレングス圧縮された $ff が終端記号のリストを解答する  
; - - -  
; 対象のエントリは, \<byte value\> \<repetitions\> のペアで 2バイト  
; 
; INPUT:  
; de = 圧縮されたリスト  
; hl = 解凍されたデータを入れるリスト  
; 
; OUTPUT: a = 解凍されたデータを入れるリストのバイト数(終端記号の$ff含む)
DecodeRLEList::
	; [wRLEByteCount] をクリア
	xor a
	ld [wRLEByteCount], a

; 圧縮されたリストを1エントリずつ解凍していく
.listLoop
; {	
	; a = byte value
	ld a, [de]
	
	; 最後までみたら -> .endOfList
	cp $ff
	jr z, .endOfList

	ld [hRLEByteValue], a

	; a = repetitions
	inc de
	ld a, [de]

	; [wRLEByteCount] += 反復回数
	ld b, $0
	ld c, a
	ld a, [wRLEByteCount]
	add c
	ld [wRLEByteCount], a

	; hl に解凍したデータを書き込んでいく
	ld a, [hRLEByteValue]
	call FillMemory
	inc de
	jr .listLoop
; }

.endOfList
	ld a, $ff
	ld [hl], a
	ld a, [wRLEByteCount]
	inc a	; a = 解凍されたデータを入れるリストのバイト数(終端記号の$ff含む)
	ret

; sets movement byte 1 for sprite [H_SPRITEINDEX] to $FE and byte 2 to [hSpriteMovementByte2]
SetSpriteMovementBytesToFE::
	push hl
	call GetSpriteMovementByte1Pointer
	ld [hl], $fe
	call GetSpriteMovementByte2Pointer
	ld a, [hSpriteMovementByte2]
	ld [hl], a
	pop hl
	ret

; **SetSpriteMovementBytesToFF**  
; スプライトをその場から動かなくさせる処理  
; - - -  
; [H_SPRITEINDEX]のスプライトの movement byte1, 2 を 0xff にする
SetSpriteMovementBytesToFF::
	push hl
	call GetSpriteMovementByte1Pointer
	ld [hl], $FF
	call GetSpriteMovementByte2Pointer
	ld [hl], $FF ; prevent person from walking?
	pop hl
	ret

; **GetSpriteMovementByte1Pointer**  
; [H_SPRITEINDEX]で指定したスプライトオフセットの movement byte 1 を hl に入れて返す  
; - - -  
; movement byte 1 は $C2X6 から取得する  
GetSpriteMovementByte1Pointer::
	ld h, $C2
	ld a, [H_SPRITEINDEX]
	swap a
	add 6
	ld l, a
	ret

; **GetSpriteMovementByte2Pointer**  
; [H_SPRITEINDEX]で指定したスプライトオフセットの movement byte 2 を hl に入れて返す  
; - - -  
; movement byte 2 は wMapSpriteData から取得する
GetSpriteMovementByte2Pointer::
	push de
	ld hl, wMapSpriteData
	ld a, [H_SPRITEINDEX]
	dec a
	add a
	ld d, 0
	ld e, a
	add hl, de
	pop de
	ret

GetTrainerInformation::
	call GetTrainerName
	ld a, [wLinkState]
	and a
	jr nz, .linkBattle
	ld a, Bank(TrainerPicAndMoneyPointers)
	call BankswitchHome
	ld a, [wTrainerClass]
	dec a
	ld hl, TrainerPicAndMoneyPointers
	ld bc, $5
	call AddNTimes
	ld de, wTrainerPicPointer
	inline "[de++] = [hl++]"
	ld a, [hli]
	ld [de], a
	ld de, wTrainerBaseMoney
	inline "[de++] = [hl++]"
	ld a, [hli]
	ld [de], a
	jp BankswitchBack
.linkBattle
	ld hl, wTrainerPicPointer
	ld de, RedPicFront
	ld [hl], e
	inc hl
	ld [hl], d
	ret

GetTrainerName::
	jpba GetTrainerName_

; プレイヤーが[hMoney]以上のお金を持っているならcarryをクリア、未満ならcarryをセット
HasEnoughMoney::
	ld de, wPlayerMoney
	ld hl, hMoney
	ld c, 3
	jp StringCmp

HasEnoughCoins::
; Check if the player has at least as many
; coins as the 2-byte BCD value at hCoins.
	ld de, wPlayerCoins
	ld hl, hCoins
	ld c, 2
	jp StringCmp

; **BankswitchHome**  
; - - - 
; aレジスタの示すバンクにスイッチ  
; home bankのときのみこれを使う
BankswitchHome::
	ld [wBankswitchHomeTemp], a
	ld a, [H_LOADEDROMBANK]
	ld [wBankswitchHomeSavedROMBank], a
	ld a, [wBankswitchHomeTemp]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **BankswitchBack**  
; - - - 
; BankswitchHome前にいたバンクに復帰
BankswitchBack::
; returns from BankswitchHome
	ld a, [wBankswitchHomeSavedROMBank]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; self-contained bankswitch, use this when not in the home bank    
; - b: スイッチしたいROMバンクの番号
; - hl: バンクスイッチした後にジャンプするアドレス 
Bankswitch::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ld bc, .Return
	push bc
	jp hl
.Return
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; displays yes/no choice
; yes -> set carry
YesNoChoice::
	call SaveScreenTilesToBuffer1
	call InitYesNoTextBoxParameters
	jr DisplayYesNoChoice

Func_35f4::
	ld a, TWO_OPTION_MENU
	ld [wTextBoxID], a
	call InitYesNoTextBoxParameters
	jp DisplayTextBoxID

InitYesNoTextBoxParameters::
	xor a ; YES_NO_MENU
	ld [wTwoOptionMenuID], a
	coord hl, 14, 7
	ld bc, $80f
	ret

YesNoChoicePokeCenter::
	call SaveScreenTilesToBuffer1
	ld a, HEAL_CANCEL_MENU
	ld [wTwoOptionMenuID], a
	coord hl, 11, 6
	lb bc, 8, 12
	jr DisplayYesNoChoice

WideYesNoChoice:: ; unused
	call SaveScreenTilesToBuffer1
	ld a, WIDE_YES_NO_MENU
	ld [wTwoOptionMenuID], a
	coord hl, 12, 7
	lb bc, 8, 13

DisplayYesNoChoice::
	ld a, TWO_OPTION_MENU
	ld [wTextBoxID], a
	call DisplayTextBoxID
	jp LoadScreenTilesFromBuffer1

; **CalcDifference**  
; abs(a-b)を計算する  a < b のときはcarryを立てる  
; - - -  
; OUTPUT:  
; a = abs(a-b)  
; carry = 0(a>b) or 1(a<b)  
CalcDifference::
	; a > b なら引くだけで問題ない
	sub b
	ret nc
	; a < b のとき
	; 2の補数で絶対値にしてキャリーを立てて終了
	cpl
	add $1
	scf
	ret

; **MoveSprite**  
; スプライトを、 movement data に従って強制的に移動させる準備  
; - - -  
; 処理の内容は、  
; wNPCMovementDirections に de で指定した movement data を配置していく処理
; 
; INPUT:  
; [H_SPRITEINDEX] = 対象のスプライトのオフセット  
; de = movement dataのアドレス (e.g. wNPCMovementDirections2)
MoveSprite::
	call SetSpriteMovementBytesToFF
MoveSprite_::
	push hl
	push bc

	; movement byte 1 = 0
	call GetSpriteMovementByte1Pointer
	xor a
	ld [hl], a

	ld hl, wNPCMovementDirections
	ld c, 0

; wNPCMovementDirections に de で指定した movement data をコピーしていく
.loop
; {
	; [hl++] = [de++]
	ld a, [de]
	ld [hli], a
	inc de

	inc c

	; movement dataを最後までみたらループを抜ける
	cp $FF
	jr nz, .loop
; }

	; [wNPCNumScriptedSteps] = movment data のエントリ数
	ld a, c
	ld [wNPCNumScriptedSteps], a

	pop bc

	; `Scripted NPC` のフラグを立てる
	ld hl, wd730
	set 0, [hl]

	pop hl

	; すべてのプレイヤーによるキー入力を無効化
	xor a
	ld [wOverrideSimulatedJoypadStatesMask], a
	ld [wSimulatedJoypadStatesEnd], a
	dec a	; a = 0xff
	ld [wJoyIgnore], a
	ld [wWastedByteCD3A], a
	ret

; [hQuotient2] = [hDividend2] // [hDivisor2]  
; Pathの処理でスプライトとプレイヤーの距離を計算する際に使用
DivideBytes::
	push hl
	ld hl, hQuotient2
	xor a
	ld [hld], a
	ld a, [hld]
	and a
	jr z, .done
	ld a, [hli]
.loop
	sub [hl]
	jr c, .done
	inc hl
	inc [hl]
	dec hl
	jr .loop
.done
	pop hl
	ret


; **LoadFontTilePatterns**  
; フォントデータをVRAMに転送する関数 
LoadFontTilePatterns::
	; LCDが有効 -> .on
	ld a, [rLCDC]
	bit 7, a
	jr nz, .on

	; LCDが無効なとき、フォントデータをすぐに全てVRAMに転送する
.off
	ld hl, FontGraphics
	ld de, vFont
	ld bc, FontGraphicsEnd - FontGraphics ; フォントデータ全体のサイズ
	ld a, BANK(FontGraphics)
	jp FarCopyDataDouble ; FontGraphics -> vFontにフォントデータを転送

	; LCDが有効なとき、VBlank中にフォントデータを少しずつVRAMに転送する
.on
	ld de, FontGraphics
	ld hl, vFont
	lb bc, BANK(FontGraphics), (FontGraphicsEnd - FontGraphics) / $8
	jp CopyVideoDataDouble ; if LCD is on, transfer during V-blank

; **LoadTextBoxTilePatterns**  
; テキストボックスの2bppデータをVRAMにロードする関数
LoadTextBoxTilePatterns::
	; LCDが有効 -> .on 無効 -> .off
	ld a, [rLCDC]
	bit 7, a
	jr nz, .on
.off
	; LCDが無効のときはすぐにすべて転送する
	ld hl, TextBoxGraphics
	ld de, vChars2 + $600
	ld bc, TextBoxGraphicsEnd - TextBoxGraphics
	ld a, BANK(TextBoxGraphics)
	jp FarCopyData2
.on
	; LCDが有効のときはVBlank中に転送する
	ld de, TextBoxGraphics
	ld hl, vChars2 + $600
	lb bc, BANK(TextBoxGraphics), (TextBoxGraphicsEnd - TextBoxGraphics) / $10
	jp CopyVideoData

; HPバーとステータスを構成する2bppデータをVRAMに転送する  
; 
; LCDCが有効か無効かによって転送時間が変わる  
; on: VBlankのときに少しずつ転送  
; off: 即座に全部転送
LoadHpBarAndStatusTilePatterns::
	; LCDCが有効なら -> .on 無効なら -> .off
	ld a, [rLCDC]
	bit 7, a
	jr nz, .on
.off
	ld hl, HpBarAndStatusGraphics
	ld de, vChars2 + $620
	ld bc, HpBarAndStatusGraphicsEnd - HpBarAndStatusGraphics
	ld a, BANK(HpBarAndStatusGraphics)
	jp FarCopyData2 ; if LCD is off, transfer all at once
.on
	ld de, HpBarAndStatusGraphics
	ld hl, vChars2 + $620
	lb bc, BANK(HpBarAndStatusGraphics), (HpBarAndStatusGraphicsEnd - HpBarAndStatusGraphics) / $10
	jp CopyVideoData ; if LCD is on, transfer during V-blank


; hlからbcバイト分をaの値で埋める
FillMemory::
	push de
	ld d, a
.loop
	ld a, d
	ld [hli], a
	dec bc
	ld a, b
	or c
	jr nz, .loop
	pop de
	ret


; **UncompressSpriteFromDE**  
; aバンクのdeにある圧縮されたpicを解凍する  
UncompressSpriteFromDE::
	; wSpriteInputPtr にdeを格納して UncompressSpriteData を呼び出す
	ld hl, wSpriteInputPtr
	ld [hl], e
	inc hl
	ld [hl], d
	jp UncompressSpriteData

; **SaveScreenTilesToBuffer2**  
; - - -  
; wTileMap の画面データを wTileMapBackup2 に移す  
SaveScreenTilesToBuffer2::
	coord hl, 0, 0
	ld de, wTileMapBackup2
	ld bc, SCREEN_WIDTH * SCREEN_HEIGHT
	call CopyData
	ret

; wTileMapBackup2に退避された画面のタイルデータをwTileMapに戻し、H_AUTOBGTRANSFERENABLED を1にする
LoadScreenTilesFromBuffer2::
	call LoadScreenTilesFromBuffer2DisableBGTransfer
	ld a, 1
	ld [H_AUTOBGTRANSFERENABLED], a
	ret

; wTileMapBackup2に退避された画面のタイルデータをwTileMapに戻す  
; ただし H_AUTOBGTRANSFERENABLED は 0にする
LoadScreenTilesFromBuffer2DisableBGTransfer::
	xor a
	ld [H_AUTOBGTRANSFERENABLED], a ; [H_AUTOBGTRANSFERENABLED] = 0
	; wTileMapBackup2 のデータを wTileMap にコピー
	ld hl, wTileMapBackup2
	coord de, 0, 0
	ld bc, SCREEN_WIDTH * SCREEN_HEIGHT
	call CopyData
	ret

; BGマップをwTileMapBackupにバックアップする
SaveScreenTilesToBuffer1::
	coord hl, 0, 0
	ld de, wTileMapBackup
	ld bc, SCREEN_WIDTH * SCREEN_HEIGHT
	jp CopyData

; wTileMapBackupにバックアップしたデータをBGマップに戻す
LoadScreenTilesFromBuffer1::
	xor a
	ld [H_AUTOBGTRANSFERENABLED], a
	ld hl, wTileMapBackup
	coord de, 0, 0
	ld bc, SCREEN_WIDTH * SCREEN_HEIGHT
	call CopyData
	ld a, 1
	ld [H_AUTOBGTRANSFERENABLED], a
	ret

; cレジスタで指定したフレームの間 haltする
DelayFrames::
	call DelayFrame
	dec c
	jr nz, DelayFrames
	ret

PlaySoundWaitForCurrent::
	push af
	call WaitForSoundToFinish
	pop af
	jp PlaySound

; Wait for sound to finish playing
WaitForSoundToFinish::
	ld a, [wLowHealthAlarm]
	and $80
	ret nz
	push hl
.waitLoop
	ld hl, wChannelSoundIDs + Ch5
	xor a
	or [hl]
	inc hl
	or [hl]
	inc hl
	inc hl
	or [hl]
	jr nz, .waitLoop
	pop hl
	ret

; アイテムのType番号 => そのTypeのアイテムの名前リストのポインタ
NamePointers::
	dw MonsterNames	; 1
	dw MoveNames	; 2
	dw UnusedNames	; 3
	dw ItemNames	; 4
	dw wPartyMonOT 	; 5 player's OT names list
	dw wEnemyMonOT 	; 6 enemy's OT names list
	dw TrainerNames	; 7

; **GetName**  
; アイテムの名前を取得する  
; - - - 
; INPUT:  
; [wd0b5] = 対象のアイテムID  
; [wNameListType] = アイテムのType ID(カテゴリ別に割り振られたID constants/list_constants.asm)  
; [wPredefBank] = リストのあるバンク番号  
;
; OUTPUT:  
; [wcd6d] = アイテム名の文字列データ  
; [wUnusedCF8D] = アイテム名終端のポインタ  
GetName::
	; [wd11e] = アイテムID
	ld a, [wd0b5]
	ld [wd11e], a

	; 技マシンは通常のアイテムと別のアイテムテーブルにあるので分岐する
	; BUG: This applies to all names instead of just items.
	cp HM_01
	jp nc, GetMachineName

	ld a, [H_LOADEDROMBANK]
	push af
	push hl
	push bc
	push de

	; 対象のアイテムリストがポケモンの名前ではないとき
	ld a, [wNameListType]    ;List3759_entrySelector
	dec a
	jr nz, .otherEntries

	; 対象の名前リストがポケモンの名前、つまりポケモンの名前を取得したいとき
	call GetMonName 
	ld hl, NAME_LENGTH
	add hl, de
	ld e, l
	ld d, h		; de = ポケモンの名前の終端文字のポインタ
	jr .gotPtr
.otherEntries
	; その他のアイテムの名前を取得したいとき (2 <= [wNameListType] <= 7)

	; アイテムの名前のリストのあるバンクにスイッチ
	ld a, [wPredefBank]
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a

	; a = 2(a-1) (2 <= a <= 7)
	ld a, [wNameListType]    ; VariousNames' entryID
	dec a
	add a

	; de = 2(a-1)
	ld d, 0
	ld e, a
	jr nc, .skip
	inc d
.skip
	; hl = アイテムの名前リストの先頭
	ld hl, NamePointers
	add hl, de
	
	; h:l = l:h
	ld a, [hli]
	ld [$ff96], a
	ld a, [hl]
	ld [$ff95], a
	ld a, [$ff95]
	ld h, a
	ld a, [$ff96]
	ld l, a

	; リストからアイテム検索
	ld a, [wd0b5]
	ld b, a
	ld c, 0
.nextName
	ld d, h
	ld e, l
.nextChar
	ld a, [hli]
	cp "@"
	jr nz, .nextChar
	inc c            ; entry counter
	ld a, b          ; wanted entry
	cp c
	jr nz, .nextName
	; hl = 該当の名前のポインタ
	ld h, d
	ld l, e

	; wcd6dにアイテム名を格納
	ld de, wcd6d
	ld bc, $0014
	call CopyData
.gotPtr
	; wUnusedCF8D = アイテムの名前の終端のアドレス
	ld a, e
	ld [wUnusedCF8D], a
	ld a, d
	ld [wUnusedCF8D + 1], a
	
	; 復帰処理
	pop de
	pop bc
	pop hl
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **GetItemPrice**  
; [hItemPrice] = アイテム価格(3バイトのBCDフォーマット)
; - - -  
; hItemPriceにBCDフォーマットのアイテム価格を格納する
;   
; INPUT: [wcf91] = アイテムID  
; OUTPUT: de = hItemPriceのアドレス
GetItemPrice::
	; バンクを保存
	ld a, [H_LOADEDROMBANK]
	push af

	; 対象のリストが技のリストでない -> aにItemPricesのあるバンクを格納して.okへ
	ld a, [wListMenuID]
	cp MOVESLISTMENU
	ld a, BANK(ItemPrices)
	jr nz, .ok
	; a = 0xf(バンク番号)
	ld a, $f ; hardcoded Bank
.ok
	; バンクスイッチ
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	
	; hl = [wItemPrices]
	ld hl, wItemPrices
	inline "hl = [hl]"
	
	; アイテムが技マシン -> .getTMPrice
	ld a, [wcf91] ; a contains item id
	cp HM_01
	jr nc, .getTMPrice

	; 通常のアイテム
	; hl += 3*アイテムID (wItemPricesは各エントリが3バイトなので)
	; アイテムIDは1から始まるのでhlはこのループ処理で次の該当アイテムの次のアイテムの価格を指すようになる
	ld bc, $3
.loop
	add hl, bc
	dec a
	jr nz, .loop

	; [hItemPrice] = アイテム価格
	dec hl
	ld a, [hld]
	ld [hItemPrice + 2], a
	ld a, [hld]
	ld [hItemPrice + 1], a
	ld a, [hl]
	ld [hItemPrice], a
	jr .done

	; [hItemPrice] = 技マシン価格
.getTMPrice
	ld a, Bank(GetMachinePrice)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call GetMachinePrice

.done
	ld de, hItemPrice
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **CopyStringToCF4B**  
; 文字列を [de] から [wcf4b] にコピー
CopyStringToCF4B::
	ld hl, wcf4b
	; fall through

; **CopyString**  
; 文字列を [de] から [hl] にコピー
CopyString::
	inline "[hl++] = [de++]"
	cp "@"
	jr nz, CopyString
	ret

; lower button sensitivityが必要なときに利用される関数(メニューなど)  
; OUTPUT: [hJoy5] = 押されたボタン(いつものフォーマット)  
; [hJoy6], [hJoy7]によってこの関数の挙動を制御することができる  
; 
; この関数には3種類の挙動が存在する  
; 1. ([hJoy7] == 0, [hJoy6] == any) -> 新たに押されたボタンだけを取得する。
;    [hJoyPressed]を[hJoy5]に単純にコピー
; 2. ([hJoy7] == 1, [hJoy6] != 0) -> 現在押されているボタンを低いサンプルレートで遅延して取得する
;    ユーザーがボタンを0.5秒以上押し続けた場合、その後ボタンが1秒あたり最大12回押されたと報告する
;    ユーザーがボタンを0.5秒より短い時間押し続けた場合、ボタンが1度だけ押されたと報告する
; 3. ([hJoy7] == 1, [hJoy6] == 0) -> 2と同じだが、A,Bボタンが押されている場合はどのボタンも押されていないと報告する
JoypadLowSensitivity::
	call Joypad

; [hJoy5] = [hJoyPressed]([hJoy7] == 0) or [hJoyHeld]([hJoy7] == 1)
	ld a, [hJoy7] ; flag
	and a ; get all currently pressed buttons or only newly pressed buttons?
	ld a, [hJoyPressed] ; newly pressed buttons
	jr z, .storeButtonState
	ld a, [hJoyHeld] ; all currently pressed buttons
.storeButtonState
	ld [hJoy5], a

	; 新たに押されたボタンがない -> .noNewlyPressedButtons
	ld a, [hJoyPressed] ; newly pressed buttons
	and a ; have any buttons been newly pressed since last check?
	jr z, .noNewlyPressedButtons

	; 新たに押されたボタンがある -> 0.5秒だけ遅延するようにしてリターン
.newlyPressedButtons
	ld a, 30 ; half a second delay
	ld [H_FRAMECOUNTER], a
	ret

	; 新たに押されたボタンがない
.noNewlyPressedButtons
	; 遅延状態が終わっている -> .delayOver
	ld a, [H_FRAMECOUNTER]
	and a ; is the delay over?
	jr z, .delayOver
	
	; 遅延中のときはキー入力(hJoy5)を0クリアしてリターン
.delayNotOver
	xor a
	ld [hJoy5], a ; report no buttons as pressed
	ret

	; 遅延中でない
.delayOver
	; [hJoy6] == 0 && A/Bが押されている => どのボタンも押されていないことにする
	
	; A/Bが押されていない -> .setShortDelay
	ld a, [hJoyHeld]
	and A_BUTTON | B_BUTTON
	jr z, .setShortDelay

	; [hJoy6] == 1 -> .setShortDelay
	ld a, [hJoy6] ; flag
	and a
	jr nz, .setShortDelay
	
	; キー入力をリセット
	xor a
	ld [hJoy5], a

	; 5フレーム(1/12秒)遅延するように
.setShortDelay
	ld a, 5 ; 1/12 of a second delay
	ld [H_FRAMECOUNTER], a
	ret

; **WaitForTextScrollButtonPress**  
; ▼ を点滅させながら、A/Bボタンの入力を待つ  
; - - -  
; タウンマップやDiplomaでも使われる？
WaitForTextScrollButtonPress::
	; [H_DOWNARROWBLINKCNT1] = 0, [H_DOWNARROWBLINKCNT2] = 6 で初期化
	ld a, [H_DOWNARROWBLINKCNT1]
	push af
	ld a, [H_DOWNARROWBLINKCNT2]
	push af
	xor a
	ld [H_DOWNARROWBLINKCNT1], a
	ld a, $6
	ld [H_DOWNARROWBLINKCNT2], a

.loop
; {
	push hl
	; タウンマップのカーソルを点滅させる
	ld a, [wTownMapSpriteBlinkingEnabled]
	and a
	jr z, .skipAnimation
	call TownMapSpriteBlinkingAnimation

.skipAnimation
	coord hl, 18, 16
	call HandleDownArrowBlinkTiming
	pop hl

	; A/Bボタンが押されたら終了
	call JoypadLowSensitivity
	predef CableClub_Run
	ld a, [hJoy5]
	and A_BUTTON | B_BUTTON
	jr z, .loop
; }

	; 終了
	pop af
	ld [H_DOWNARROWBLINKCNT2], a
	pop af
	ld [H_DOWNARROWBLINKCNT1], a
	ret

; A/Bボタンが入力されるのを待って、テキストのスクロールサウンドを出す(通信対戦は除く)
ManualTextScroll::
	ld a, [wLinkState]
	cp LINK_STATE_BATTLING
	jr z, .inLinkBattle
	call WaitForTextScrollButtonPress
	ld a, SFX_PRESS_AB
	jp PlaySound
.inLinkBattle
	ld c, 65
	jp DelayFrames

; **Multiply**  
; 掛け算を行う関数  
; - - -  
; GBZ80 には mul命令 がないため関数として定義する必要がある  
; すべての値は ビッグエンディアン として扱う  
; 
; c = a * b
; 
; INPUT  
; FF96-FF98 =  被乗数(a)  
; FF99 = 乗数(b)
; 
; OUTPUT  
; FF95-FF98 = 掛け算の結果(c)
Multiply::
	push hl
	push bc
	callab _Multiply
	pop bc
	pop hl
	ret


; **Divide**  
; 割り算を行う関数  
; - - -  
; GBZ80 には div命令 がないため関数として定義する必要がある  
; すべての値は ビッグエンディアン として扱う  
; 
; z = x / y
; 
; INPUT:  
; b = dividendのバイト長  
; FF95-FF98 =  dividend(x)  
; FF99 = divisor(y)  
; 
; OUTPUT:  
; FF95-FF98 = 商  
; FF99 = 余り  
Divide::
	push hl
	push de
	push bc
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, Bank(_Divide)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call _Divide
	pop af
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	pop bc
	pop de
	pop hl
	ret

; **PrintLetterDelay**  
; 文字を描画した後に待機することでテキストの速さを調整する  
; - - -  
; プレイヤーによってA/Bボタンを押されていないときに文字を描画した後で少し待つ処理を行う  
PrintLetterDelay::
	; 遅延フラグが立っていない　つまり 一気に表示するテキストの場合 -> return
	ld a, [wd730]
	bit 6, a
	ret nz

	ld a, [wLetterPrintingDelayFlags]
	bit 1, a
	ret z

	push hl
	push de
	push bc

; [H_FRAMECOUNTER] = 待機するフレーム
	; [wLetterPrintingDelayFlags] が最優先
	ld a, [wLetterPrintingDelayFlags]
	bit 0, a
	jr z, .waitOneFrame
	; 設定の もじのはやさ を使う
	ld a, [wOptions]
	and $f
	ld [H_FRAMECOUNTER], a
	jr .checkButtons
.waitOneFrame
	ld a, 1
	ld [H_FRAMECOUNTER], a

.checkButtons
	call Joypad
	ld a, [hJoyHeld]

.checkAButton
	; Aボタンが押された -> .endWait
	bit 0, a
	jr z, .checkBButton
	jr .endWait

.checkBButton
	; Bボタンが押された -> .endWait
	bit 1, a
	jr z, .buttonsNotPressed

.endWait
	call DelayFrame
	jr .done

.buttonsNotPressed ; if neither A nor B is pressed
	ld a, [H_FRAMECOUNTER]
	and a
	jr nz, .checkButtons
	
.done
	pop bc
	pop de
	pop hl
	ret

; **CopyDataUntil**  
; [hl, bc) -> [de, de+(bc - hl) )にコピーする  
; - - -  
; hlからbc-1までをdeにコピーする
CopyDataUntil::
	inline "[de++] = [hl++]"
	
	; hl+1 == bcになるまで続ける
	ld a, h
	cp b
	jr nz, CopyDataUntil
	ld a, l
	cp c
	jr nz, CopyDataUntil
	ret

; **RemovePokemon**  
; 手持ちか、現在のPCBoxから指定したポケモンを逃がす(削除する)関数  
; - - -  
; INPUT:  
; wWhichPokemon = どのポケモンが対象か(インデックス番号)  
; [wRemoveMonFromBox] = 0(手持ちから) or 1(PCBoxから)  
RemovePokemon::
	jpab _RemovePokemon

; **AddPartyMon**  
; 新しいポケモンを主人公かライバルの手持ちに加える  
; - - -  
; この関数では [wMonDataLocation] が通常とは異なる使われ方をすることに注意  
; 
; INPUT:  
; [wcf91] = 加える対象のポケモンの内部ID  
; 
; OUTPUT:  
; carry = 手持ちに加えることに成功したときにセットされる  
; wPartyMons(wEnemyMons) = 加えたポケモンのデータがセットされる  
AddPartyMon::
	push hl
	push de
	push bc
	callba _AddPartyMon
	pop bc
	pop de
	pop hl
	ret

; calculates all 5 stats of current mon and writes them to [de]
CalcStats::
	ld c, $0
.statsLoop
	inc c
	call CalcStat
	ld a, [H_MULTIPLICAND+1]
	ld [de], a
	inc de
	ld a, [H_MULTIPLICAND+2]
	ld [de], a
	inc de
	ld a, c
	cp NUM_STATS
	jr nz, .statsLoop
	ret

; **CalcStat**  
; 現在のポケモンのステータス(Cレジスタで指定)を計算する  
; - - -  
; INPUT:  
; c = 計算対象のステータス (HP=1,Atk=2,Def=3,Spd=4,Spc=5)  
; b = 努力値(stat exp)を考慮するか?  
; hl = 努力値を格納したアドレス ([hl + 2*c - 1] and [hl + 2*c])  
; 
; OUTPUT:  
; [H_MULTIPLICAND+1] = ステータス1 (上位桁)  
; [H_MULTIPLICAND+2] = ステータス2 (下位桁)  
CalcStat::
	push hl
	push de
	push bc
	ld a, b
	ld d, a ; d = 努力値を考慮するか?

	; e = 計算対象のステータスの種族値
	push hl
	ld hl, wMonHeader
	ld b, $0
	add hl, bc
	ld a, [hl]          ; read base value of stat
	ld e, a
	pop hl

	push hl
	sla c

	; 努力値を考慮しない場合 -> .statExpDone
	ld a, d
	and a
	jr z, .statExpDone

	add hl, bc          ; skip to corresponding stat exp value

; b = ceil(√努力値)
.statExpLoop
	xor a
	ld [H_MULTIPLICAND], a
	ld [H_MULTIPLICAND+1], a
	inc b               ; increment current stat exp bonus
	ld a, b
	cp $ff
	jr z, .statExpDone
	ld [H_MULTIPLICAND+2], a
	ld [H_MULTIPLIER], a
	call Multiply
	ld a, [hld]
	ld d, a
	ld a, [$ff98]
	sub d
	ld a, [hli]
	ld d, a
	ld a, [$ff97]
	sbc d               ; test if (current stat exp bonus)^2 < stat exp
	jr c, .statExpLoop

.statExpDone
	srl c ; c = 計算対象のステータス (HP=1,Atk=2,Def=3,Spd=4,Spc=5)
	pop hl	; hl = 努力値を格納したアドレス ([hl + 2*c - 1] and [hl + 2*c]) 

	; hl = 計算対象の DVsのアドレス (wPartyMon1DVs[i])
	push bc
	ld bc, wPartyMon1DVs - (wPartyMon1HPExp - 1) ; also wEnemyMonDVs - wEnemyMonHP
	add hl, bc
	pop bc

; ここから .calcStatFromIV　までの処理で計算対象のステータスの個体値を取得する
	; c の値によって処理を分岐
	; c == 1のときは下の .getHpIV
	ld a, c
	cp $2
	jr z, .getAttackIV
	cp $3
	jr z, .getDefenseIV
	cp $4
	jr z, .getSpeedIV
	cp $5
	jr z, .getSpecialIV

.getHpIV
	push bc
	ld a, [hl]  ; Atk IV
	swap a
	and $1
	sla a
	sla a
	sla a
	ld b, a
	ld a, [hli] ; Def IV
	and $1
	sla a
	sla a
	add b
	ld b, a
	ld a, [hl] ; Spd IV
	swap a
	and $1
	sla a
	add b
	ld b, a
	ld a, [hl] ; Spc IV
	and $1
	add b      ; HP IV: LSB of the other 4 IVs
	pop bc
	jr .calcStatFromIV
.getAttackIV
	ld a, [hl] ; a = 攻撃の個体値
	swap a
	and $f
	jr .calcStatFromIV
.getDefenseIV
	ld a, [hl]
	and $f
	jr .calcStatFromIV
.getSpeedIV
	inc hl
	ld a, [hl]
	swap a
	and $f
	jr .calcStatFromIV
.getSpecialIV
	inc hl
	ld a, [hl]
	and $f

; この時点で 
; a = 計算対象の個体値 (IV)
; b = ceil(√努力値) = ceil(Sqrt(stat exp))
; e = 計算対象の種族値 (Base)

.calcStatFromIV
	ld d, $0
	add e
	ld e, a
	jr nc, .noCarry
	inc d                     ; de = Base + IV
.noCarry
	sla e
	rl d                      ; de = (Base + IV) * 2
	srl b
	srl b                     ; b = ceil(Sqrt(stat exp)) / 4
	ld a, b
	add e
	jr nc, .noCarry2
	inc d                     ; de = (Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4
.noCarry2
	ld [H_MULTIPLICAND+2], a
	ld a, d
	ld [H_MULTIPLICAND+1], a
	xor a
	ld [H_MULTIPLICAND], a
	ld a, [wCurEnemyLVL]
	ld [H_MULTIPLIER], a
	call Multiply            ; ((Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4) * Level
	ld a, [H_MULTIPLICAND]
	ld [H_DIVIDEND], a
	ld a, [H_MULTIPLICAND+1]
	ld [H_DIVIDEND+1], a
	ld a, [H_MULTIPLICAND+2]
	ld [H_DIVIDEND+2], a
	ld a, $64
	ld [H_DIVISOR], a
	ld a, $3
	ld b, a
	call Divide             ; (((Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4) * Level) / 100
	ld a, c
	cp $1
	ld a, 5 ; + 5 for non-HP stat
	jr nz, .notHPStat
	ld a, [wCurEnemyLVL]
	ld b, a
	ld a, [H_MULTIPLICAND+2]
	add b
	ld [H_MULTIPLICAND+2], a
	jr nc, .noCarry3
	ld a, [H_MULTIPLICAND+1]
	inc a
	ld [H_MULTIPLICAND+1], a ; HP: (((Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4) * Level) / 100 + Level
.noCarry3
	ld a, 10 ; +10 for HP stat
.notHPStat
	ld b, a
	ld a, [H_MULTIPLICAND+2]
	add b
	ld [H_MULTIPLICAND+2], a
	jr nc, .noCarry4
	ld a, [H_MULTIPLICAND+1]
	inc a                    ; non-HP: (((Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4) * Level) / 100 + 5
	ld [H_MULTIPLICAND+1], a ; HP: (((Base + IV) * 2 + ceil(Sqrt(stat exp)) / 4) * Level) / 100 + Level + 10
.noCarry4
	ld a, [H_MULTIPLICAND+1] ; check for overflow (>999)
	cp 999 / $100 + 1
	jr nc, .overflow
	cp 999 / $100
	jr c, .noOverflow
	ld a, [H_MULTIPLICAND+2]
	cp 999 % $100 + 1
	jr c, .noOverflow
.overflow
	ld a, 999 / $100               ; overflow: cap at 999
	ld [H_MULTIPLICAND+1], a
	ld a, 999 % $100
	ld [H_MULTIPLICAND+2], a
.noOverflow
	pop bc
	pop de
	pop hl
	ret

AddEnemyMonToPlayerParty::
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(_AddEnemyMonToPlayerParty)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	call _AddEnemyMonToPlayerParty
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **MoveMon**  
; ポケモンを別のデータスロットに移動させる処理  
; - - -  
; 移動した後のデータクリアはここではしない  
; 
; INPUT: [wMoveMonType] = BOX_TO_PARTY or PARTY_TO_BOX or DAYCARE_TO_PARTY or PARTY_TO_DAYCARE
; OUTPUT: carry = 0(成功) or 1(移動先がいっぱいで失敗)  
MoveMon::
	; バンクを退避
	ld a, [H_LOADEDROMBANK]
	push af
	ld a, BANK(_MoveMon)
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	; 処理の本体
	call _MoveMon
	; バンクを復帰
	pop bc
	ld a, b
	ld [H_LOADEDROMBANK], a
	ld [MBC1RomBank], a
	ret

; **SkipFixedLengthTextEntries**  
; hl += NAME_LENGTH * a  
; - - -  
; hlで指定したアドレスに対して(NAME_LENGTH * a)つまり11*aを足す  
; skips a text entries, each of size NAME_LENGTH (like trainer name, OT name, rival name, ...)  
SkipFixedLengthTextEntries::
	; a = 0なら返る
	and a
	ret z

	; hl += NAME_LENGTH * a
	ld bc, NAME_LENGTH
.skipLoop
	add hl, bc
	dec a
	jr nz, .skipLoop
	ret

; add bc to hl a times  
; hl += a * bc
AddNTimes::
	and a
	ret z
.loop
	add hl, bc
	dec a
	jr nz, .loop
	ret

; **StringCmp**  
; de と hl を cバイトだけ文字列として比較する  
; - - -  
; バトルの計算処理でビッグエンディアンの数値を比較するのに用いられる  
;  
; OUTPUT:  
; de > hl -> carry is 0  
; de == hl -> carry is 0  
; de < hl -> carry is 1  
StringCmp::
	ld a, [de]
	cp [hl]
	ret nz
	inc de
	inc hl
	dec c
	jr nz, StringCmp
	ret

; **WriteOAMBlock**  
; OAMBufferにOAM blockのデータを書き込む  
; OAM block: 2*2のOAMタイルの塊  
; - - - 
; INPUT:  
; a = OAM blockのインデックス  
; b = OAM blockの左上角のYcoord  
; c = OAM blockの左上角のXcoord  
; de = OAM blockの4つのタイル番号と属性のペアの開始アドレス  
WriteOAMBlock::
	; hl = 対象のOAM block のwOAMBufferでの開始アドレス
	ld h, wOAMBuffer / $100
	swap a ; *= 16 => 各OAM blockは16バイトなので
	ld l, a

	call .writeOneEntry ; upper left
	push bc
	ld a, 8
	add c
	ld c, a
	call .writeOneEntry ; upper right
	pop bc
	ld a, 8
	add b
	ld b, a
	call .writeOneEntry ; lower left
	ld a, 8
	add c
	ld c, a				
	; fallthrough		  lower right 

	; INPUT: [hl] = OAMエントリ
.writeOneEntry
	ld [hl], b ; Y coordinate
	inc hl
	ld [hl], c ; X coordinate
	inc hl
	inline "[hl++] = [de++]"	; tile番号
	inline "[hl++] = [de++]"	; attr
	ret

; **HandleMenuInput**  
; メニューでのキー入力に対処するハンドラ  
; - - - 
; INPUT: [wMenuWatchedKeys] = 反応する対象のキー入力 上下ボタンは必ず反応して選択オフセットを上下に移動させる  
; 
; OUTPUT:  
; a = キー入力 [↓, ↑, ←, →, Start, Select, B, A]  
; [wCurrentMenuItem] = 選択されたメニューアイテム  
; [wMenuCursorLocation] = カーソルのあるタイルのアドレス  
HandleMenuInput::
	; 選択メニューがポケモン選択メニュー(手持ちポケモン一覧など)のときに選択しているポケモン以外のアニメーションを無効にする?
	xor a
	ld [wPartyMenuAnimMonEnabled], a

; **HandleMenuInput_**  
; menu でのキー入力に対処するハンドラ  
; - - - 
; INPUT: [wMenuWatchedKeys] = 反応する対象のキー入力 上下ボタンは必ず反応して選択オフセットを上下に移動させる  
; 
; OUTPUT:  
; a = キー入力 [↓, ↑, ←, →, Start, Select, B, A]  
; [wCurrentMenuItem] = 選択されたメニューアイテム  
; [wMenuCursorLocation] = カーソルのあるタイルのアドレス  
HandleMenuInput_::
	; H_DOWNARROWBLINKCNT1/2を退避
	ld a, [H_DOWNARROWBLINKCNT1]
	push af
	ld a, [H_DOWNARROWBLINKCNT2]
	push af ; save existing values on stack

	; カーソル点滅速度を変更
	; H_DOWNARROWBLINKCNT1 = 0
	; H_DOWNARROWBLINKCNT2 = 6
	xor a
	ld [H_DOWNARROWBLINKCNT1], a ; blinking down arrow timing value 1
	ld a, 6
	ld [H_DOWNARROWBLINKCNT2], a ; blinking down arrow timing value 2
.loop1
	; 選択メニューで選択している行にカーソルを配置
	xor a
	ld [wAnimCounter], a ; counter for pokemon shaking animation
	call PlaceMenuCursor
	call Delay3
.loop2
	push hl

	; 選択メニューがポケモン選択メニューでない
	ld a, [wPartyMenuAnimMonEnabled]
	and a ; is it a pokemon selection menu?
	jr z, .getJoypadState

	; 選択メニューがポケモン選択メニューならポケモンのアイコンのアニメーション処理を行う
	callba AnimatePartyMon ; shake mini sprite of selected pokemon
.getJoypadState
	pop hl
	
	; キー入力があった場合 -> .keyPressed
	call JoypadLowSensitivity
	ld a, [hJoy5]
	and a ; was a key pressed?
	jr nz, .keyPressed

	push hl

	; (18, 11)で"▼"を点滅させる
	coord hl, 18, 11 ; coordinates of blinking down arrow in some menus
	call HandleDownArrowBlinkTiming ; blink down arrow (if any)

	pop hl

	; 時間切れ
	ld a, [wMenuJoypadPollCount]
	dec a
	jr z, .giveUpWaiting

	jr .loop2

.giveUpWaiting
	; 一定回数のチェックの間にキー入力がされなかった場合

	; 退避したH_DOWNARROWBLINKCNT1/2を復帰して戻る 
	pop af
	ld [H_DOWNARROWBLINKCNT2], a
	pop af
	ld [H_DOWNARROWBLINKCNT1], a ; restore previous values
	; menu wrappingを無効化
	xor a
	ld [wMenuWrappingEnabled], a
	ret

.keyPressed
	; [wCheckFor180DegreeTurn] = 0
	xor a
	ld [wCheckFor180DegreeTurn], a

	; 上ボタンを押したか確認
	ld a, [hJoy5]
	ld b, a
	bit 6, a ; pressed Up key?
	jr z, .checkIfDownPressed	; 次は下ボタンのチェック

; 上ボタンを押したとき
.upPressed
	; 一番上を選択中かどうか
	ld a, [wCurrentMenuItem] ; selected menu item
	and a ; already at the top of the menu?
	jr z, .alreadyAtTop
.notAtTop
	; 選択オフセットをデクリメントする
	dec a
	ld [wCurrentMenuItem], a ; move selected menu item up one space
	jr .checkOtherKeys
.alreadyAtTop
	; menu wrappingが有効、つまり一周回って一番下に戻るか 
	ld a, [wMenuWrappingEnabled]
	and a ; is wrapping around enabled?
	jr z, .noWrappingAround

	; menu wrappingが有効なら一番下に戻る
	ld a, [wMaxMenuItem]
	ld [wCurrentMenuItem], a ; wrap to the bottom of the menu
	jr .checkOtherKeys
	
; 下ボタンのチェック(上ボタンと同様)
.checkIfDownPressed
	bit 7, a
	jr z, .checkOtherKeys
.downPressed
	ld a, [wCurrentMenuItem]
	inc a
	ld c, a
	ld a, [wMaxMenuItem]
	cp c
	jr nc, .notAtBottom
.alreadyAtBottom
	ld a, [wMenuWrappingEnabled]
	and a ; is wrapping around enabled?
	jr z, .noWrappingAround
	ld c, $00 ; wrap from bottom to top
.notAtBottom
	ld a, c
	ld [wCurrentMenuItem], a

	; ほかのボタンのチェック
.checkOtherKeys
	; [hJoy5] & [wMenuWatchedKeys] > 0 つまりチェックしているボタンのいずれかが押されているか確認
	ld a, [wMenuWatchedKeys]
	and b ; does the menu care about any of the pressed keys?
	jp z, .loop1
.checkIfAButtonOrBButtonPressed
	; 押されたのがA/Bボタンか
	ld a, [hJoy5]
	and A_BUTTON | B_BUTTON
	jr z, .skipPlayingSound
.AButtonOrBButtonPressed
	; A/Bボタンが押されたときはPress時のSEを鳴らす

	; Press時にSEを鳴らすフラグが有効かチェック
	push hl
	ld hl, wFlags_0xcd60
	bit 5, [hl]
	pop hl
	jr nz, .skipPlayingSound
	; SEを鳴らす
	ld a, SFX_PRESS_AB
	call PlaySound
.skipPlayingSound
	; 退避したH_DOWNARROWBLINKCNT1/2を復帰
	pop af
	ld [H_DOWNARROWBLINKCNT2], a
	pop af
	ld [H_DOWNARROWBLINKCNT1], a ; restore previous values
	; menu wrappingを無効化
	xor a
	ld [wMenuWrappingEnabled], a ; disable menu wrapping

	; 押したキーをaに入れて返る
	ld a, [hJoy5]
	ret
.noWrappingAround
	ld a, [wMenuWatchMovingOutOfBounds]
	and a ; should we return if the user tried to go past the top or bottom?
	jr z, .checkOtherKeys
	jr .checkIfAButtonOrBButtonPressed

; **PlaceMenuCursor**  
; menu にカーソルを表示させる
; - - -   
; INPUT:  
; [wCurrentMenuItem] = 現在選択しているアイテムの画面上でのオフセット  
; [wLastMenuItem] = wCurrentMenuItem の前に選択していたアイテムの画面上でのオフセット  
PlaceMenuCursor::

; hl = (wTopMenuItemX, wTopMenuItemY)のタイルのポインタ
	ld a, [wTopMenuItemY]
	and a ; is the y coordinate 0?
	jr z, .adjustForXCoord	
	coord hl, 0, 0
	ld bc, SCREEN_WIDTH
.topMenuItemLoop
	add hl, bc
	dec a
	jr nz, .topMenuItemLoop
.adjustForXCoord
	ld a, [wTopMenuItemX]
	ld b, 0
	ld c, a
	add hl, bc
	push hl

; hl = (wTopMenuItemX, wTopMenuItemY+wLastMenuItem)のタイルのポインタ
	ld a, [wLastMenuItem]
	and a
	jr z, .checkForArrow1
	push af
	; bc = 各行の行間の大きさ = 20(1タイル) or 40(2タイル) 
	ld a, [hFlags_0xFFF6]
	bit 1, a ; is the menu double spaced?
	jr z, .doubleSpaced1
	ld bc, SCREEN_WIDTH
	jr .getOldMenuItemScreenPosition
.doubleSpaced1
	ld bc, SCREEN_WIDTH*2
.getOldMenuItemScreenPosition
	pop af
.oldMenuItemLoop
	add hl, bc
	dec a
	jr nz, .oldMenuItemLoop

; (wTopMenuItemX, wTopMenuItemY+wLastMenuItem)にカーソルが出ているときはカーソルを消す
.checkForArrow1
	ld a, [hl]
	cp "▶" ; was an arrow next to the previously selected menu item?
	jr nz, .skipClearingArrow
.clearArrow
	ld a, [wTileBehindCursor]
	ld [hl], a

.skipClearingArrow
	pop hl	; hl = (wTopMenuItemX, wTopMenuItemY)のタイルのポインタ

; hl = (wTopMenuItemX, wTopMenuItemY+wCurrentMenuItem)のタイルのポインタ
	ld a, [wCurrentMenuItem]
	and a
	jr z, .checkForArrow2
	push af
	ld a, [hFlags_0xFFF6]
	bit 1, a ; is the menu double spaced?
	jr z, .doubleSpaced2
	ld bc, 20
	jr .getCurrentMenuItemScreenPosition
.doubleSpaced2
	ld bc, 40
.getCurrentMenuItemScreenPosition
	pop af	; a = [wCurrentMenuItem]
.currentMenuItemLoop
	add hl, bc
	dec a
	jr nz, .currentMenuItemLoop

; 現在選択中の位置にカーソルを表示させる
.checkForArrow2
	ld a, [hl]
	cp "▶" ; has the right arrow already been placed?
	jr z, .skipSavingTile ; if so, don't lose the saved tile
	ld [wTileBehindCursor], a ; save tile before overwriting with right arrow
.skipSavingTile
	ld a, "▶" ; place right arrow
	ld [hl], a

	; [wMenuCursorLocation] = カーソルのタイルポインタ
	ld a, l
	ld [wMenuCursorLocation], a
	ld a, h
	ld [wMenuCursorLocation + 1], a

	; wLastMenuItemを更新
	ld a, [wCurrentMenuItem]
	ld [wLastMenuItem], a
	ret

; **PlaceUnfilledArrowMenuCursor**  
; 現在有効ではないカーソルを ▷ とする  
; - - -  
; ネストしたメニューの場合は、親メニューのメニューカーソルの場所を示すために使用  
; アイテムの入れ替えの場合には、これは最初に選んだアイテムを保存するために使用  
; 
; OUTPUT: [wMenuCursorLocation]の示すwTileMapのタイル = ▷
PlaceUnfilledArrowMenuCursor::
	ld b, a
	; hl = [wMenuCursorLocation]
	ld a, [wMenuCursorLocation]
	ld l, a
	ld a, [wMenuCursorLocation + 1]
	ld h, a
	; [wMenuCursorLocation]の示すアドレス = ▷
	ld [hl], "▷"
	ld a, b
	ret

; メニューカーソルのタイルを空白のタイルで置き換える
EraseMenuCursor::
	ld a, [wMenuCursorLocation]
	ld l, a
	ld a, [wMenuCursorLocation + 1]
	ld h, a
	ld [hl], " "
	ret

; **HandleDownArrowBlinkTiming**  
; タイルhlで"▼"を一定時間ごとに点滅させる関数  
; - - -  
; 点滅が生じないときもしばしば呼び出されている  
; これは、これを呼び出すほとんどの関数がH_DOWNARROWBLINKCNT1を0に初期化するためである  
; この関数はタイルhlに"▼"がセットされている場合は"▼"の点滅を行うが、セットされていない場合は何もしない  
; そのため点滅が生じないときもとりあえずこの関数を呼び出すといったことをしても問題にはならない   
HandleDownArrowBlinkTiming::
	; [hl] == " " -> .downArrowOff
	ld a, [hl]
	ld b, a
	ld a, "▼"
	cp b
	jr nz, .downArrowOff

.downArrowOn
	; [hl] == "▼"のときここにくる

	; [H_DOWNARROWBLINKCNT1]--
	ld a, [H_DOWNARROWBLINKCNT1]
	dec a
	ld [H_DOWNARROWBLINKCNT1], a
	ret nz	; [H_DOWNARROWBLINKCNT1] > 0 ならreturn

	; [H_DOWNARROWBLINKCNT1] == 0 になったとき [H_DOWNARROWBLINKCNT2]--
	ld a, [H_DOWNARROWBLINKCNT2]
	dec a
	ld [H_DOWNARROWBLINKCNT2], a
	ret nz	; [H_DOWNARROWBLINKCNT2] > 0 なら return

	; [H_DOWNARROWBLINKCNT2] == 0 になったときに ▼ を消す
	ld a, " "
	ld [hl], a
	ld a, $ff
	ld [H_DOWNARROWBLINKCNT1], a
	ld a, $06
	ld [H_DOWNARROWBLINKCNT2], a
	ret

.downArrowOff
	ld a, [H_DOWNARROWBLINKCNT1]
	and a
	ret z

	dec a
	ld [H_DOWNARROWBLINKCNT1], a
	ret nz

	dec a
	ld [H_DOWNARROWBLINKCNT1], a
	ld a, [H_DOWNARROWBLINKCNT2]
	dec a
	ld [H_DOWNARROWBLINKCNT2], a
	ret nz

	ld a, $06
	ld [H_DOWNARROWBLINKCNT2], a
	ld a, "▼"
	ld [hl], a
	ret

; The following code either enables or disables the automatic drawing of
; text boxes by DisplayTextID. Both functions cause DisplayTextID to wait
; for a button press after displaying text (unless [wEnteringCableClub] is set).
; 以下のコードは`DisplayTextID`によるテキストボックスの自動的な描画を有効化/無効化をする処理

; `DisplayTextID`によるテキストボックスの自動的な描画を有効化
EnableAutoTextBoxDrawing::
	xor a
	jr AutoTextBoxDrawingCommon

; `DisplayTextID`によるテキストボックスの自動的な描画を無効化
DisableAutoTextBoxDrawing::
	ld a, $01

; **AutoTextBoxDrawingCommon**  
; 自動で会話が進むテキスト  
; - - -  
; INPUT: a = 0(無効化) or 1(有効化)  
AutoTextBoxDrawingCommon::
	ld [wAutoTextBoxDrawingControl], a
	xor a
	ld [wDoNotWaitForButtonPressAfterDisplayingText], a ; make DisplayTextID wait for button press
	ret

; **PrintText**  
; - - -  
; 8*8のタイル単位で(1, 14)にテキストhlを表示する
PrintText::
	push hl
	ld a, MESSAGE_BOX
	ld [wTextBoxID], a
	call DisplayTextBoxID
	call UpdateSprites
	call Delay3
	pop hl
	; fallthrough

; (1, 14)にテキストhl を表示する(テキストボックスは無し)
PrintText_NoCreatingTextBox::
	coord bc, 1, 14
	jp TextCommandProcessor

; **PrintNumber**  
; c桁かつbバイトの数値をdeに表示する
; - - - 
; 桁数は2-7桁の範囲で表示される 1桁を指定したときはPrintNumberを呼び出す代わりに先頭に0の文字を付ける  
; フラグLEADING ZEROSおよびLEFT ALIGNは、それぞれbのビット7および6で指定できる
PrintNumber::
	push bc
	xor a
	ld [H_PASTLEADINGZEROES], a
	ld [H_NUMTOPRINT], a
	ld [H_NUMTOPRINT + 1], a
	ld a, b
	and $f
	cp 1
	jr z, .byte
	cp 2
	jr z, .word
.long
	ld a, [de]
	ld [H_NUMTOPRINT], a
	inc de
	ld a, [de]
	ld [H_NUMTOPRINT + 1], a
	inc de
	ld a, [de]
	ld [H_NUMTOPRINT + 2], a
	jr .start

.word
	ld a, [de]
	ld [H_NUMTOPRINT + 1], a
	inc de
	ld a, [de]
	ld [H_NUMTOPRINT + 2], a
	jr .start

.byte
	ld a, [de]
	ld [H_NUMTOPRINT + 2], a

.start
	push de

	ld d, b
	ld a, c
	ld b, a
	xor a
	ld c, a
	ld a, b

	cp 2
	jr z, .tens
	cp 3
	jr z, .hundreds
	cp 4
	jr z, .thousands
	cp 5
	jr z, .ten_thousands
	cp 6
	jr z, .hundred_thousands

print_digit: MACRO

IF (\1) / $10000
	ld a, \1 / $10000 % $100
ELSE
	xor a
ENDC
	ldh [H_POWEROFTEN + 0], a

IF (\1) / $100
	ld a, \1 / $100   % $100
ELSE
	xor a
ENDC
	ldh [H_POWEROFTEN + 1], a

	ld a, \1 / $1     % $100
	ldh [H_POWEROFTEN + 2], a

	call .PrintDigit
	call .NextDigit
ENDM

.millions          print_digit 1000000
.hundred_thousands print_digit 100000
.ten_thousands     print_digit 10000
.thousands         print_digit 1000
.hundreds          print_digit 100

.tens
	ld c, 0
	ld a, [H_NUMTOPRINT + 2]
.mod
	cp 10
	jr c, .ok
	sub 10
	inc c
	jr .mod
.ok

	ld b, a
	ld a, [H_PASTLEADINGZEROES]
	or c
	ld [H_PASTLEADINGZEROES], a
	jr nz, .past
	call .PrintLeadingZero
	jr .next
.past
	ld a, "0"
	add c
	ld [hl], a
.next

	call .NextDigit
.ones
	ld a, "0"
	add b
	ld [hli], a
	pop de
	dec de
	pop bc
	ret

.PrintDigit:
; Divide by the current decimal place.
; Print the quotient, and keep the modulus.
	ld c, 0
.loop
	ld a, [H_POWEROFTEN]
	ld b, a
	ld a, [H_NUMTOPRINT]
	ld [H_SAVEDNUMTOPRINT], a
	cp b
	jr c, .underflow0
	sub b
	ld [H_NUMTOPRINT], a
	ld a, [H_POWEROFTEN + 1]
	ld b, a
	ld a, [H_NUMTOPRINT + 1]
	ld [H_SAVEDNUMTOPRINT + 1], a
	cp b
	jr nc, .noborrow1

	ld a, [H_NUMTOPRINT]
	or 0
	jr z, .underflow1
	dec a
	ld [H_NUMTOPRINT], a
	ld a, [H_NUMTOPRINT + 1]
.noborrow1

	sub b
	ld [H_NUMTOPRINT + 1], a
	ld a, [H_POWEROFTEN + 2]
	ld b, a
	ld a, [H_NUMTOPRINT + 2]
	ld [H_SAVEDNUMTOPRINT + 2], a
	cp b
	jr nc, .noborrow2

	ld a, [H_NUMTOPRINT + 1]
	and a
	jr nz, .borrowed

	ld a, [H_NUMTOPRINT]
	and a
	jr z, .underflow2
	dec a
	ld [H_NUMTOPRINT], a
	xor a
.borrowed

	dec a
	ld [H_NUMTOPRINT + 1], a
	ld a, [H_NUMTOPRINT + 2]
.noborrow2
	sub b
	ld [H_NUMTOPRINT + 2], a
	inc c
	jr .loop

.underflow2
	ld a, [H_SAVEDNUMTOPRINT + 1]
	ld [H_NUMTOPRINT + 1], a
.underflow1
	ld a, [H_SAVEDNUMTOPRINT]
	ld [H_NUMTOPRINT], a
.underflow0
	ld a, [H_PASTLEADINGZEROES]
	or c
	jr z, .PrintLeadingZero

	ld a, "0"
	add c
	ld [hl], a
	ld [H_PASTLEADINGZEROES], a
	ret

.PrintLeadingZero:
	bit BIT_LEADING_ZEROES, d
	ret z
	ld [hl], "0"
	ret

.NextDigit:
; Increment unless the number is left-aligned,
; leading zeroes are not printed, and no digits
; have been printed yet.
	bit BIT_LEADING_ZEROES, d
	jr nz, .inc
	bit BIT_LEFT_ALIGN, d
	jr z, .inc
	ld a, [H_PASTLEADINGZEROES]
	and a
	ret z
.inc
	inc hl
	ret


; **CallFunctionInTable**  
; jumptable hlの 関数a をcallする  
; - - -  
; deだけは値が変わる可能性がある
CallFunctionInTable::
	push hl
	push de
	push bc
	add a
	ld d, 0
	ld e, a
	add hl, de
	inline "hl = [hl]"
	ld de, .returnAddress
	push de	; call hl
	jp hl
.returnAddress
	pop bc
	pop de
	pop hl
	ret


; **IsInArray**  
; 配列hlからaの値を探す 配列は終端が必ず$ff  
; 配列の各要素のサイズはdeで表される  
; 
; 見つかれば、bに対象のインデックスを入れてキャリーをセットして返る  
; このときhlは対象の要素を指している
IsInArray::
	ld b, 0	; インデックスを初期化

IsInRestOfArray::
	ld c, a
.loop
	; 最後まで探したが無い
	ld a, [hl]
	cp -1
	jr z, .notfound

	; 見つかった
	cp c
	jr z, .found

	; 次の要素に
	inc b		; ここでインデックスが加算されている
	add hl, de
	jr .loop

.notfound
	and a		; キャリーをクリア
	ret

.found
	scf			; キャリーをセット
	ret


RestoreScreenTilesAndReloadTilePatterns::
	call ClearSprites
	; スプライトの表示を有効化
	ld a, $1
	ld [wUpdateSpritesEnabled], a
	; スプライトデータ、タイルデータ、その他をoverworld状態に戻す
	call ReloadMapSpriteTilePatterns
	call LoadScreenTilesFromBuffer2
	call LoadTextBoxTilePatterns
	call RunDefaultPaletteCommand ; SGBのみ
	jr Delay3


; GBPalWhiteOut -> 3フレーム待機 -> GBPalNormal
GBPalWhiteOutWithDelay3::
	call GBPalWhiteOut


; bg mapが3回に分けて各フレームごとに更新される(計3フレーム)  
; bg mapが完全に更新されるように3フレーム待つ処理  
Delay3::
	ld c, 3
	jp DelayFrames

; BGPとOBP0を通常のパレットデータに戻す  
; [rBGP] = %11100100  
; [rOBP0] = %11010000  
GBPalNormal::
	ld a, %11100100 ; 3210
	ld [rBGP], a
	ld a, %11010000 ; 3100
	ld [rOBP0], a
	ret

; すべてのパレットを白一色にする
GBPalWhiteOut::
	xor a
	ld [rBGP], a
	ld [rOBP0], a
	ld [rOBP1], a
	ret

; **RunDefaultPaletteCommand**  
; SGBでないなら何もせずに終了  
RunDefaultPaletteCommand::
	ld b, $ff
; **RunPaletteCommand**  
; SGBでないなら何もせずに終了  
RunPaletteCommand::
	; SGBのときに _RunPaletteCommand (ポケモンのHPバーに色(緑,橙,赤)をつける必要があるので)
	ld a, [wOnSGB]
	and a
	ret z
	predef_jump _RunPaletteCommand

; **GetHealthBarColor**  
; e で与えられたHPゲージのピクセルの長さに応じたHPゲージの色番号を [hl] に入れて返す  
; - - -  
; OUTPUT:  
; [hl] -> 0: green (pixel >= 27)  
; [hl] -> 1: orange (pixel >= 10)  
; [hl] -> 2: red (pixel < 10)  
GetHealthBarColor::
	ld a, e
	cp 27
	ld d, 0 ; green
	jr nc, .gotColor
	cp 10
	inc d ; yellow
	jr nc, .gotColor
	inc d ; red
.gotColor
	ld [hl], d
	ret

; 何かしらの処理で別のタイルパターンで上書きされたVRAMに対して現在のマップのスプライトデータを再びコピーするための関数
ReloadMapSpriteTilePatterns::
	ld hl, wFontLoaded
	ld a, [hl]
	push af
	res 0, [hl]
	push hl
	xor a
	ld [wSpriteSetID], a
	call DisableLCD
	callba InitMapSprites
	call EnableLCD
	pop hl
	pop af
	ld [hl], a
	call LoadPlayerSpriteGraphics
	call LoadFontTilePatterns
	jp UpdateSprites

; **GiveItem**  
; bに格納したアイテムID で指定したアイテムを C個 プレイヤーに渡し、渡したアイテムの名前を wcf4b に格納する  
; 成功時にはキャリーを立てる  
GiveItem::
	ld a, b
	ld [wd11e], a
	ld [wcf91], a
	ld a, c
	ld [wItemQuantity], a
	ld hl, wNumBagItems
	call AddItemToInventory
	ret nc
	call GetItemName
	call CopyStringToCF4B
	scf
	ret

; **GivePokemon**  
; プレイヤーにレベルcのポケモンbを与える  
; - - -  
; 
; OUTPUT:  
; - carry = 0(失敗) or 1(成功)
; - [wAddedToParty] = ポケモンがBoxではなく手持ちに入ったかどうか
GivePokemon::
	ld a, b
	ld [wcf91], a
	ld a, c
	ld [wCurEnemyLVL], a
	xor a ; PLAYER_PARTY_DATA
	ld [wMonDataLocation], a
	jpba _GivePokemon

; 乱数[$0, $ff]をAレジスタと [hRandomAdd] に入れて返す関数  
; バトルのときはこの関数ではなくBattleRandomを利用している
Random::
	push hl
	push de
	push bc
	callba Random_		; 16bitの乱数を生成
	ld a, [hRandomAdd]	; 生成した16bitの乱数のうち8bitだけ利用
	pop bc
	pop de
	pop hl
	ret


INCLUDE "home/predef.asm"


UpdateCinnabarGymGateTileBlocks::
	jpba UpdateCinnabarGymGateTileBlocks_

; **CheckForHiddenObjectOrBookshelfOrCardKeyDoor**  
; hidden objectか本棚やジムの石像などのアイテムやカードキーで開くドアが目の前にあるかチェック  
; - - -  
; hidden objectの場合は、そのobject routineまで行う  
; OUTPUT: [$ffeb] = 0x00 or 0xff
CheckForHiddenObjectOrBookshelfOrCardKeyDoor::
	ld a, [H_LOADEDROMBANK]
	push af

	; Aボタンが押されていない -> .nothingFound
	ld a, [hJoyHeld]
	bit 0, a ; A button
	jr z, .nothingFound

	; Aボタンが押されている

	; hidden object がないなら -> .hiddenObjectNotFound
	ld a, Bank(CheckForHiddenObject)
	ld [MBC1RomBank], a
	ld [H_LOADEDROMBANK], a
	call CheckForHiddenObject
	ld a, [$ffee]
	and a
	jr nz, .hiddenObjectNotFound
	ld a, [wHiddenObjectFunctionRomBank]
	ld [MBC1RomBank], a
	ld [H_LOADEDROMBANK], a

	; hidden objectがあった場合は call object routine 
	ld de, .returnAddress
	push de
	jp hl

.returnAddress
	xor a
	jr .done

.hiddenObjectNotFound
	callba PrintBookshelfText
	ld a, [$ffdb]
	and a
	jr z, .done

.nothingFound
	ld a, $ff

.done
	ld [$ffeb], a
	pop af
	ld [MBC1RomBank], a
	ld [H_LOADEDROMBANK], a
	ret

; **PrintPredefTextID**  
; PredefTextを画面に描画する  
; - - -  
; INPUT: a = TextPredefs(PredefTextのテーブル)のオフセット
PrintPredefTextID::
	ld [hSpriteIndexOrTextID], a
	ld hl, TextPredefs
	call SetMapTextPointer

	; wTextPredefFlag[0]をセット
	ld hl, wTextPredefFlag
	set 0, [hl]
	call DisplayTextID

RestoreMapTextPointer::
	ld hl, wMapTextPtr
	ld a, [$ffec]
	ld [hli], a
	ld a, [$ffec + 1]
	ld [hl], a
	ret

; **SetMapTextPointer**  
; - - -
; [$ffec] = [wMapTextPtr] の後に [wMapTextPtr] = hlを行う
SetMapTextPointer::
	; [$ffec] = [wMapTextPtr]
	ld a, [wMapTextPtr]
	ld [$ffec], a
	ld a, [wMapTextPtr + 1]
	ld [$ffec + 1], a

	; [wMapTextPtr] = hl
	ld a, l
	ld [wMapTextPtr], a
	ld a, h
	ld [wMapTextPtr + 1], a
	ret

; **TextPredefs**  
; PredefTextID -> PredefText  
; - - -  
; PrintPredefTextID で利用されるPredefTextを定義したテーブル  
TextPredefs::
const_value = 1

	add_tx_pre CardKeySuccessText                   ; 01
	add_tx_pre CardKeyFailText                      ; 02
	add_tx_pre RedBedroomPCText                     ; 03
	add_tx_pre RedBedroomSNESText                   ; 04
	add_tx_pre PushStartText                        ; 05
	add_tx_pre SaveOptionText                       ; 06
	add_tx_pre StrengthsAndWeaknessesText           ; 07
	add_tx_pre OakLabEmailText                      ; 08
	add_tx_pre AerodactylFossilText                 ; 09
	add_tx_pre Route15UpstairsBinocularsText        ; 0A
	add_tx_pre KabutopsFossilText                   ; 0B
	add_tx_pre GymStatueText1                       ; 0C
	add_tx_pre GymStatueText2                       ; 0D
	add_tx_pre BookcaseText                         ; 0E
	add_tx_pre ViridianCityPokecenterBenchGuyText   ; 0F
	add_tx_pre PewterCityPokecenterBenchGuyText     ; 10
	add_tx_pre CeruleanCityPokecenterBenchGuyText   ; 11
	add_tx_pre LavenderCityPokecenterBenchGuyText   ; 12
	add_tx_pre VermilionCityPokecenterBenchGuyText  ; 13
	add_tx_pre CeladonCityPokecenterBenchGuyText    ; 14
	add_tx_pre CeladonCityHotelText                 ; 15
	add_tx_pre FuchsiaCityPokecenterBenchGuyText    ; 16
	add_tx_pre CinnabarIslandPokecenterBenchGuyText ; 17
	add_tx_pre SaffronCityPokecenterBenchGuyText    ; 18
	add_tx_pre MtMoonPokecenterBenchGuyText         ; 19
	add_tx_pre RockTunnelPokecenterBenchGuyText     ; 1A
	add_tx_pre UnusedBenchGuyText1                  ; 1B XXX unused
	add_tx_pre UnusedBenchGuyText2                  ; 1C XXX unused
	add_tx_pre UnusedBenchGuyText3                  ; 1D XXX unused
	add_tx_pre UnusedPredefText                     ; 1E XXX unused
	add_tx_pre PokemonCenterPCText                  ; 1F
	add_tx_pre ViridianSchoolNotebook               ; 20
	add_tx_pre ViridianSchoolBlackboard             ; 21
	add_tx_pre JustAMomentText                      ; 22
	add_tx_pre OpenBillsPCText                      ; 23
	add_tx_pre FoundHiddenItemText                  ; 24
	add_tx_pre HiddenItemBagFullText                ; 25 XXX unused
	add_tx_pre VermilionGymTrashText                ; 26
	add_tx_pre IndigoPlateauHQText                  ; 27
	add_tx_pre GameCornerOutOfOrderText             ; 28
	add_tx_pre GameCornerOutToLunchText             ; 29
	add_tx_pre GameCornerSomeonesKeysText           ; 2A
	add_tx_pre FoundHiddenCoinsText                 ; 2B
	add_tx_pre DroppedHiddenCoinsText               ; 2C
	add_tx_pre BillsHouseMonitorText                ; 2D
	add_tx_pre BillsHouseInitiatedText              ; 2E
	add_tx_pre BillsHousePokemonList                ; 2F
	add_tx_pre MagazinesText                        ; 30
	add_tx_pre CinnabarGymQuiz                      ; 31
	add_tx_pre GameCornerNoCoinsText                ; 32
	add_tx_pre GameCornerCoinCaseText               ; 33
	add_tx_pre LinkCableHelp                        ; 34
	add_tx_pre TMNotebook                           ; 35
	add_tx_pre FightingDojoText                     ; 36
	add_tx_pre EnemiesOnEverySideText               ; 37
	add_tx_pre WhatGoesAroundComesAroundText        ; 38
	add_tx_pre NewBicycleText                       ; 39
	add_tx_pre IndigoPlateauStatues                 ; 3A
	add_tx_pre VermilionGymTrashSuccessText1        ; 3B
	add_tx_pre VermilionGymTrashSuccessText2        ; 3C XXX unused
	add_tx_pre VermilionGymTrashSuccessText3        ; 3D
	add_tx_pre VermilionGymTrashFailText            ; 3E
	add_tx_pre TownMapText                          ; 3F
	add_tx_pre BookOrSculptureText                  ; 40
	add_tx_pre ElevatorText                         ; 41
	add_tx_pre PokemonStuffText                     ; 42
